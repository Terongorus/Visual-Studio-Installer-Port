<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.CodeAnalysis.InteractiveHost</name>
    </assembly>
    <members>
        <member name="T:Microsoft.CodeAnalysis.Interactive.InteractiveHost">
            <summary>
            Represents a process that hosts an interactive session.
            </summary>
            <remarks>
            Handles spawning of the host process and communication between the local callers and the remote session.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Interactive.InteractiveHost.OutputEncoding">
            <summary>
            Use Unicode encoding for STDOUT and STDERR of the InteractiveHost process.
            Ideally, we would use UTF8 but SetConsoleOutputCP Windows API fails with "Invalid Handle" when Console.OutputEncoding is set to UTF8.
            (issue tracked by https://github.com/dotnet/roslyn/issues/47571, https://devdiv.visualstudio.com/DevDiv/_workitems/edit/1253106)
            Unicode is not ideal since the message printed directly to STDOUT/STDERR from native code that do not encode the output are going to be garbled
            (e.g. messages reported by CLR stack overflow and OOM exception handlers: https://github.com/dotnet/runtime/issues/45503).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Interactive.InteractiveHost._joinOutputWritingThreadsOnDisposal">
            <remarks>
            Test only setting.
            True to join output writing threads when the host is being disposed.
            We have to join the threads before each test is finished, otherwise xunit won't be able to unload the AppDomain.
            WARNING: Joining the threads might deadlock if <see cref="M:Microsoft.CodeAnalysis.Interactive.InteractiveHost.Dispose"/> is executing on the UI thread, 
            since the threads are dispatching to UI thread to write the output to the editor buffer.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Interactive.InteractiveHost.ResetAsync(Microsoft.CodeAnalysis.Interactive.InteractiveHostOptions)">
            <summary>
            Restarts and reinitializes the host process (or starts a new one if it is not running yet).
            </summary>
            <param name="options">The options to initialize the new process with.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Interactive.InteractiveHost.ExecuteAsync(System.String)">
            <summary>
            Asynchronously executes given code in the remote interactive session.
            </summary>
            <param name="code">The code to execute.</param>
            <remarks>
            This method is thread safe but operations are sent to the remote process
            asynchronously so tasks should be executed serially if order is important.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Interactive.InteractiveHost.ExecuteFileAsync(System.String)">
            <summary>
            Asynchronously executes given code in the remote interactive session.
            </summary>
            <param name="path">The file to execute.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is null.</exception>
            <remarks>
            This method is thread safe but operations are sent to the remote process
            asynchronously so tasks should be executed serially if order is important.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Interactive.InteractiveHost.AddReferenceAsync(System.String)">
            <summary>
            Asynchronously adds a reference to the set of available references for next submission.
            </summary>
            <param name="reference">The reference to add.</param>
            <remarks>
            This method is thread safe but operations are sent to the remote process
            asynchronously so tasks should be executed serially if order is important.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Interactive.InteractiveHost.SetPathsAsync(System.Collections.Immutable.ImmutableArray{System.String},System.Collections.Immutable.ImmutableArray{System.String},System.String)">
            <summary>
            Sets the current session's search paths and base directory.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Interactive.InteractiveHost.Service">
            <summary>
            A remote singleton server-activated object that lives in the interactive host process and controls it.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Interactive.InteractiveHost.Service.RunServerAsync(System.String,System.Int32,System.Func{System.Func{System.Object},System.Object})">
            <summary>
            Implements remote server.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Interactive.InteractiveHost.Service.InitializeContextAsync(System.String,System.Boolean)">
            <summary>
            Reads given initialization file (.rsp) and loads and executes all assembly references and files, respectively specified in it.
            Execution is performed on the UI thread.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Interactive.InteractiveHost.Service.AddReferenceAsync(System.String)">
            <summary>
            Adds an assembly reference to the current session.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Interactive.InteractiveHost.Service.ExecuteAsync(System.String)">
            <summary>
            Executes given script snippet on the UI thread in the context of the current session.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Interactive.InteractiveHost.Service.ExecuteFileAsync(System.String)">
            <summary>
            Remote API. Executes given script file on the UI thread in the context of the current session.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Interactive.InteractiveHost.Service.InitializeContextAsync(System.Threading.Tasks.Task{Microsoft.CodeAnalysis.Interactive.InteractiveHost.Service.EvaluationState},System.Threading.Tasks.TaskCompletionSource{Microsoft.CodeAnalysis.Interactive.RemoteExecutionResult},System.String,System.Boolean)">
            <summary>
            Loads references, set options and execute files specified in the initialization file.
            Also prints logo unless <paramref name="isRestarting"/> is true.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Interactive.InteractiveHost.Service.TryExecuteFileAsync(Microsoft.CodeAnalysis.Interactive.InteractiveHost.Service.EvaluationState,System.String)">
            <summary>
            Executes specified script file as a submission.
            </summary>
            <remarks>
            All errors are written to the error output stream.
            Uses source search paths to resolve unrooted paths.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Interactive.InteractiveHost.Service.RemoteConsoleWriteAsync(System.Byte[],System.Boolean)">
            <summary>
            Remote API for testing purposes.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Interactive.InteractiveHost.Service.GetRuntimeDirectoryAsync">
            <summary>
            Remote API for testing purposes.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Interactive.InteractiveHost.ShadowCopyReference">
            <summary>
            Specialize <see cref="T:Microsoft.CodeAnalysis.PortableExecutableReference"/> with path being the original path of the copy.
            Logically this reference represents that file, the fact that we load the image from a copy is an implementation detail.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Interactive.InteractiveHostOptions">
            <summary>
            Settings that affect InteractiveHost process and initialization.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Interactive.InteractiveHostOptions.HostPath">
            <summary>
            Path to interactive host executable.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Interactive.InteractiveHostOptions.InitializationFilePath">
            <summary>
            Optional file name of the .rsp file to use to initialize the REPL.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Interactive.InteractiveHostOptions.Culture">
            <summary>
            Host culture used for data formatting.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Interactive.InteractiveHostOptions.UICulture">
            <summary>
            Host culture used for localization of doc comments, errors.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Interactive.InteractiveHostOptions.Platform">
            <summary>
            Host process platform.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Interactive.RemoteExecutionResult.SourcePaths">
            <summary>
            New value of source search paths after execution.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Interactive.RemoteExecutionResult.ReferencePaths">
            <summary>
            New value of reference search paths after execution.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Interactive.RemoteExecutionResult.WorkingDirectory">
            <summary>
            New value of working directory in the remote process after execution.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Interactive.RemoteInitializationResult.ScriptPath">
            <summary>
            Full path to the initialization script that has been executed as part of initialization process.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Interactive.InteractiveHostResources.Cannot_resolve_reference_0">
            <summary>Cannot resolve reference '{0}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Interactive.InteractiveHostResources.Loading_context_from_0">
            <summary>Loading context from '{0}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Interactive.InteractiveHostResources.Type_Sharphelp_for_more_information">
            <summary>Type "#help" for more information.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Interactive.InteractiveHostResources.Specified_file_not_found_colon_0">
            <summary>Specified file not found: {0}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Interactive.InteractiveHostResources.Specified_file_not_found">
            <summary>Specified file not found.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Interactive.InteractiveHostResources.Searched_in_directory_colon">
            <summary>Searched in directory:</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Interactive.InteractiveHostResources.Searched_in_directories_colon">
            <summary>Searched in directories:</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Interactive.InteractiveHostResources.plus_additional_0_1">
            <summary>+ additional {0} {1}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Interactive.InteractiveHostResources.Unable_to_create_hosting_process">
            <summary>Unable to create hosting process.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Interactive.InteractiveHostResources.Hosting_process_exited_with_exit_code_0">
            <summary>Hosting process exited with exit code {0}.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Interactive.InteractiveHostResources.Failed_to_launch_0_process_exit_code_colon_1_with_output_colon">
            <summary>Failed to launch '{0}' process (exit code: {1}) with output:</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Interactive.InteractiveHostResources.Failed_to_create_a_remote_process_for_interactive_code_execution">
            <summary>Failed to create a remote process for interactive code execution: '{0}'</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FailFast.Handler">
            <summary>
            A pre-created delegate to assign to <see cref="T:Microsoft.CodeAnalysis.ErrorReporting.FatalError.ErrorReporterHandler" /> if needed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FailFast.DumpStackTrace(System.Exception,System.String)">
            <summary>
            Dumps the stack trace of the exception and the handler to the console. This is useful
            for debugging unit tests that hit a fatal exception
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FailFast.Assert(System.Boolean,System.String)">
            <summary>
            Checks for the given <paramref name="condition"/>; if the <paramref name="condition"/> is <c>true</c>, 
            immediately terminates the process without running any pending <c>finally</c> blocks or finalizers
            and causes a crash dump to be collected (if the system is configured to do so). 
            Otherwise, the process continues normally.
            </summary>
            <param name="condition">The conditional expression to evaluate.</param>
            <param name="message">An optional message to be recorded in the dump in case of failure. Can be <c>null</c>.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ErrorReporting.OperationCanceledIgnoringCallerTokenException">
            <summary>
            Thrown when async code must cancel the current execution but does not have access to the <see cref="T:System.Threading.CancellationTokenSource"/> of the <see cref="T:System.Threading.CancellationToken"/> passed to the code.
            Should be used in very rare cases where the <see cref="T:System.Threading.CancellationTokenSource"/> is out of our control (e.g. owned but not exposed by JSON RPC in certain call-back scenarios).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ErrorReporting.FatalError.SetHandlers(Microsoft.CodeAnalysis.ErrorReporting.FatalError.ErrorReporterHandler,Microsoft.CodeAnalysis.ErrorReporting.FatalError.ErrorReporterHandler)">
            <summary>
            Set by the host to handle an error report; this may crash the process or report telemetry.
            </summary>
            <param name="nonFatalHandler">A handler that will not crash the process when called.  Used when calling <see
            cref="M:Microsoft.CodeAnalysis.ErrorReporting.FatalError.ReportNonFatalError(System.Exception,Microsoft.CodeAnalysis.ErrorReporting.ErrorSeverity,System.Boolean)"/></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ErrorReporting.FatalError.OverwriteHandler(Microsoft.CodeAnalysis.ErrorReporting.FatalError.ErrorReporterHandler)">
            <summary>
            Same as setting the Handler property except that it avoids the assert.  This is useful in
            test code which needs to verify the handler is called in specific cases and will continually
            overwrite this value.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ErrorReporting.FatalError.CopyHandlersTo(System.Reflection.Assembly)">
            <summary>
            Copies the handler in this instance to the linked copy of this type in this other assembly.
            </summary>
            <remarks>
            This file is in linked into multiple layers, but we want to ensure that all layers have the same copy.
            This lets us copy the handler in this instance into the same in another instance.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ErrorReporting.FatalError.ReportAndPropagate(System.Exception,Microsoft.CodeAnalysis.ErrorReporting.ErrorSeverity)">
            <summary>
            Use in an exception filter to report an error without catching the exception.
            The error is reported by calling <see cref="F:Microsoft.CodeAnalysis.ErrorReporting.FatalError.s_handler"/>.
            </summary>
            <returns><see langword="false"/> to avoid catching the exception.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ErrorReporting.FatalError.ReportAndPropagateUnlessCanceled(System.Exception,Microsoft.CodeAnalysis.ErrorReporting.ErrorSeverity)">
            <summary>
            Use in an exception filter to report an error (by calling <see cref="F:Microsoft.CodeAnalysis.ErrorReporting.FatalError.s_handler"/>), unless the
            operation has been cancelled. The exception is never caught.
            </summary>
            <returns><see langword="false"/> to avoid catching the exception.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ErrorReporting.FatalError.ReportAndPropagateUnlessCanceled(System.Exception,System.Threading.CancellationToken,Microsoft.CodeAnalysis.ErrorReporting.ErrorSeverity)">
             <summary>
             <para>Use in an exception filter to report an error (by calling <see cref="F:Microsoft.CodeAnalysis.ErrorReporting.FatalError.s_handler"/>), unless the
             operation has been cancelled at the request of <paramref name="contextCancellationToken"/>. The exception is
             never caught.</para>
            
             <para>Cancellable operations are only expected to throw <see cref="T:System.OperationCanceledException"/> if the
             applicable <paramref name="contextCancellationToken"/> indicates cancellation is requested by setting
             <see cref="P:System.Threading.CancellationToken.IsCancellationRequested"/>. Unexpected cancellation, i.e. an
             <see cref="T:System.OperationCanceledException"/> which occurs without <paramref name="contextCancellationToken"/>
             requesting cancellation, is treated as an error by this method.</para>
            
             <para>This method does not require <see cref="P:System.OperationCanceledException.CancellationToken"/> to match
             <paramref name="contextCancellationToken"/>, provided cancellation is expected per the previous
             paragraph.</para>
             </summary>
             <param name="contextCancellationToken">A <see cref="T:System.Threading.CancellationToken"/> which will have
             <see cref="P:System.Threading.CancellationToken.IsCancellationRequested"/> set if cancellation is expected.</param>
             <returns><see langword="false"/> to avoid catching the exception.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ErrorReporting.FatalError.ReportAndCatch(System.Exception,Microsoft.CodeAnalysis.ErrorReporting.ErrorSeverity)">
            <summary>
            Report an error.
            Calls <see cref="F:Microsoft.CodeAnalysis.ErrorReporting.FatalError.s_handler"/> and doesn't pass the exception through (the method returns true).
            This is generally expected to be used within an exception filter as that allows us to
            capture data at the point the exception is thrown rather than when it is handled.
            However, it can also be used outside of an exception filter. If the exception has not
            already been thrown the method will throw and catch it itself to ensure we get a useful
            stack trace.
            </summary>
            <returns>True to catch the exception.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ErrorReporting.FatalError.ReportAndCatchUnlessCanceled(System.Exception,Microsoft.CodeAnalysis.ErrorReporting.ErrorSeverity)">
            <summary>
            Use in an exception filter to report an error (by calling <see cref="F:Microsoft.CodeAnalysis.ErrorReporting.FatalError.s_handler"/>) and catch
            the exception, unless the operation was cancelled.
            </summary>
            <returns><see langword="true"/> to catch the exception if the error was reported; otherwise,
            <see langword="false"/> to propagate the exception if the operation was cancelled.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ErrorReporting.FatalError.ReportAndCatchUnlessCanceled(System.Exception,System.Threading.CancellationToken,Microsoft.CodeAnalysis.ErrorReporting.ErrorSeverity)">
             <summary>
             <para>Use in an exception filter to report an error (by calling <see cref="F:Microsoft.CodeAnalysis.ErrorReporting.FatalError.s_handler"/>) and
             catch the exception, unless the operation was cancelled at the request of
             <paramref name="contextCancellationToken"/>.</para>
            
             <para>Cancellable operations are only expected to throw <see cref="T:System.OperationCanceledException"/> if the
             applicable <paramref name="contextCancellationToken"/> indicates cancellation is requested by setting
             <see cref="P:System.Threading.CancellationToken.IsCancellationRequested"/>. Unexpected cancellation, i.e. an
             <see cref="T:System.OperationCanceledException"/> which occurs without <paramref name="contextCancellationToken"/>
             requesting cancellation, is treated as an error by this method.</para>
            
             <para>This method does not require <see cref="P:System.OperationCanceledException.CancellationToken"/> to match
             <paramref name="contextCancellationToken"/>, provided cancellation is expected per the previous
             paragraph.</para>
             </summary>
             <param name="contextCancellationToken">A <see cref="T:System.Threading.CancellationToken"/> which will have
             <see cref="P:System.Threading.CancellationToken.IsCancellationRequested"/> set if cancellation is expected.</param>
             <returns><see langword="true"/> to catch the exception if the error was reported; otherwise,
             <see langword="false"/> to propagate the exception if the operation was cancelled.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ErrorReporting.FatalError.ReportNonFatalError(System.Exception,Microsoft.CodeAnalysis.ErrorReporting.ErrorSeverity,System.Boolean)">
            <summary>
            Used to report a non-fatal-watson (when possible) to report an exception.  The exception is not caught. Does
            nothing if no non-fatal error handler is registered.  See the second argument to <see
            cref="M:Microsoft.CodeAnalysis.ErrorReporting.FatalError.SetHandlers(Microsoft.CodeAnalysis.ErrorReporting.FatalError.ErrorReporterHandler,Microsoft.CodeAnalysis.ErrorReporting.FatalError.ErrorReporterHandler)"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ErrorReporting.ErrorSeverity">
            <summary>
            The severity of the error, see the enum members for a description of when to use each. This is metadata that's included
            in a non-fatal fault report, which we can take advantage of on the backend to automatically triage bugs. For example,
            a critical severity issue we can open with a lower bug count compared to a low priority one.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ErrorReporting.ErrorSeverity.Uncategorized">
            <summary>
            The severity hasn't been categorized. Don't use this in new code.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ErrorReporting.ErrorSeverity.Diagnostic">
            <summary>
            Something failed, but the user is unlikely to notice. Especially useful for background things that we can silently recover
            from, like bugs in caching systems.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ErrorReporting.ErrorSeverity.General">
            <summary>
            Something failed, and the user might notice, but they're still likely able to carry on. For example, if the user
            asked for some information from the IDE (find references, completion, etc.) and we were able to give partial results.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ErrorReporting.ErrorSeverity.Critical">
            <summary>
            Something failed, and the user likely noticed. For example, the user pressed a button to do an action, and
            we threw an exception so we completely failed to do that in an unrecoverable way. This may also be used
            for back-end systems where a failure is going to result in a highly broken experience, for example if parsing a file
            catastrophically failed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ArrayBuilderExtensions.SelectAsArray``2(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{``0},System.Func{``0,``1})">
            <summary>
            Maps an array builder to immutable array.
            </summary>
            <typeparam name="TItem"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="items">The array to map</param>
            <param name="map">The mapping delegate</param>
            <returns>If the items's length is 0, this will return an empty immutable array</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ArrayBuilderExtensions.SelectAsArray``3(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{``0},System.Func{``0,``1,``2},``1)">
            <summary>
            Maps an array builder to immutable array.
            </summary>
            <typeparam name="TItem"></typeparam>
            <typeparam name="TArg"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="items">The sequence to map</param>
            <param name="map">The mapping delegate</param>
            <param name="arg">The extra input used by mapping delegate</param>
            <returns>If the items's length is 0, this will return an empty immutable array.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ArrayBuilderExtensions.SelectAsArrayWithIndex``3(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{``0},System.Func{``0,System.Int32,``1,``2},``1)">
            <summary>
            Maps an array builder to immutable array.
            </summary>
            <typeparam name="TItem"></typeparam>
            <typeparam name="TArg"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="items">The sequence to map</param>
            <param name="map">The mapping delegate</param>
            <param name="arg">The extra input used by mapping delegate</param>
            <returns>If the items's length is 0, this will return an empty immutable array.</returns>
        </member>
        <member name="F:Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1.PooledArrayLengthLimitExclusive">
            <summary>
            See <see cref="M:Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1.Free"/> for an explanation of this constant value.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1.ToImmutable">
            <summary>
            Realizes the array.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1.ToImmutableAndClear">
            <summary>
            Realizes the array and clears the collection.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1.SetItem(System.Int32,`0)">
            <summary>
            Write <paramref name="value"/> to slot <paramref name="index"/>. 
            Fills in unallocated slots preceding the <paramref name="index"/>, if any.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1.ToImmutableOrNull">
            <summary>
            Realizes the array.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1.ToDowncastedImmutable``1">
            <summary>
            Realizes the array, downcasting each element to a derived type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1.ToImmutableAndFree">
            <summary>
            Realizes the array and disposes the builder in one operation.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1.Enumerator">
            <summary>
            struct enumerator used in foreach.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.PooledObjects.ObjectPool`1">
            <summary>
            Generic implementation of object pooling pattern with predefined pool size limit. The main
            purpose is that limited number of frequently used objects can be kept in the pool for
            further recycling.
            
            Notes: 
            1) it is not the goal to keep all returned objects. Pool is not meant for storage. If there
               is no space in the pool, extra returned objects will be dropped.
            
            2) it is implied that if object was obtained from a pool, the caller will return it back in
               a relatively short time. Keeping checked out objects for long durations is ok, but 
               reduces usefulness of pooling. Just new up your own.
            
            Not returning objects to the pool in not detrimental to the pool's work, but is a bad practice. 
            Rationale: 
               If there is no intent for reusing the object, do not use pool - just use "new". 
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.PooledObjects.ObjectPool`1.Factory">
            <remarks>
            Not using System.Func{T} because this file is linked into the (debugger) Formatter,
            which does not have that type (since it compiles against .NET 2.0).
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PooledObjects.ObjectPool`1.Allocate">
            <summary>
            Produces an instance.
            </summary>
            <remarks>
            Search strategy is a simple linear probing which is chosen for it cache-friendliness.
            Note that Free will try to store recycled objects close to the start thus statistically 
            reducing how far we will typically search.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PooledObjects.ObjectPool`1.Free(`0)">
            <summary>
            Returns objects to the pool.
            </summary>
            <remarks>
            Search strategy is a simple linear probing which is chosen for it cache-friendliness.
            Note that Free will try to store recycled objects close to the start thus statistically 
            reducing how far we will typically search in Allocate.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PooledObjects.ObjectPool`1.ForgetTrackedObject(`0,`0)">
            <summary>
            Removes an object from leak tracking.  
            
            This is called when an object is returned to the pool.  It may also be explicitly 
            called if an object allocated from the pool is intentionally not being returned
            to the pool.  This can be of use with pooled arrays if the consumer wants to 
            return a larger array to the pool than was originally allocated.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Threading.AsyncBatchingWorkQueue">
            <inheritdoc cref="T:Microsoft.CodeAnalysis.Threading.AsyncBatchingWorkQueue`2"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Threading.AsyncBatchingWorkQueue.#ctor(System.TimeSpan,System.Func{System.Threading.CancellationToken,System.Threading.Tasks.ValueTask},Microsoft.CodeAnalysis.Shared.TestHooks.IAsynchronousOperationListener,System.Threading.CancellationToken)">
            <inheritdoc cref="T:Microsoft.CodeAnalysis.Threading.AsyncBatchingWorkQueue`2"/>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Threading.AsyncBatchingWorkQueue`1">
            <inheritdoc cref="T:Microsoft.CodeAnalysis.Threading.AsyncBatchingWorkQueue`2"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Threading.AsyncBatchingWorkQueue`1.#ctor(System.TimeSpan,System.Func{Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList{`0},System.Threading.CancellationToken,System.Threading.Tasks.ValueTask},System.Collections.Generic.IEqualityComparer{`0},Microsoft.CodeAnalysis.Shared.TestHooks.IAsynchronousOperationListener,System.Threading.CancellationToken)">
            <inheritdoc cref="T:Microsoft.CodeAnalysis.Threading.AsyncBatchingWorkQueue`2"/>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Threading.AsyncBatchingWorkQueue`2">
            <summary>
            A queue where items can be added to to be processed in batches after some delay has passed. When processing
            happens, all the items added since the last processing point will be passed along to be worked on.  Rounds of
            processing happen serially, only starting up after a previous round has completed.
            <para>
            Failure to complete a particular batch (either due to cancellation or some faulting error) will not prevent
            further batches from executing. The only thing that will permenantly stop this queue from processing items is if
            the <see cref="T:System.Threading.CancellationToken"/> passed to the constructor switches to <see
            cref="P:System.Threading.CancellationToken.IsCancellationRequested"/>.
            </para>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Threading.AsyncBatchingWorkQueue`2._delay">
            <summary>
            Delay we wait after finishing the processing of one batch and starting up on then.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Threading.AsyncBatchingWorkQueue`2._equalityComparer">
            <summary>
            Equality comparer uses to dedupe items if present.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Threading.AsyncBatchingWorkQueue`2._processBatchAsync">
            <summary>
            Callback to actually perform the processing of the next batch of work.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Threading.AsyncBatchingWorkQueue`2._entireQueueCancellationToken">
            <summary>
            Cancellation token controlling the entire queue.  Once this is triggered, we don't want to do any more work
            at all.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Threading.AsyncBatchingWorkQueue`2._cancellationSeries">
            <summary>
            Cancellation series we use so we can cancel individual batches of work if requested.  The client of the
            queue can cancel existing work by either calling <see cref="M:Microsoft.CodeAnalysis.Threading.AsyncBatchingWorkQueue`2.CancelExistingWork"/> directly, or passing <see
            langword="true"/> to <see cref="M:Microsoft.CodeAnalysis.Threading.AsyncBatchingWorkQueue`2.AddWork(`0,System.Boolean)"/>.  Work in the queue that has not started will be
            immediately discarded. The cancellation token passed to <see cref="F:Microsoft.CodeAnalysis.Threading.AsyncBatchingWorkQueue`2._processBatchAsync"/> will be triggered
            allowing the client callback to cooperatively cancel the current batch of work it is performing.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Threading.AsyncBatchingWorkQueue`2._gate">
            <summary>
            Lock we will use to ensure the remainder of these fields can be accessed in a threadsafe
            manner.  When work is added we'll place the data into <see cref="F:Microsoft.CodeAnalysis.Threading.AsyncBatchingWorkQueue`2._nextBatch"/>.
            We'll then kick of a task to process this in the future if we don't already have an
            existing task in flight for that.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Threading.AsyncBatchingWorkQueue`2._nextBatch">
            <summary>
            Data added that we want to process in our next update task.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Threading.AsyncBatchingWorkQueue`2._nextBatchCancellationToken">
            <summary>
            CancellationToken controlling the next batch of items to execute.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Threading.AsyncBatchingWorkQueue`2._uniqueItems">
            <summary>
            Used if <see cref="F:Microsoft.CodeAnalysis.Threading.AsyncBatchingWorkQueue`2._equalityComparer"/> is present to ensure only unique items are added to <see
            cref="F:Microsoft.CodeAnalysis.Threading.AsyncBatchingWorkQueue`2._nextBatch"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Threading.AsyncBatchingWorkQueue`2._updateTask">
            <summary>
            Task kicked off to do the next batch of processing of <see cref="F:Microsoft.CodeAnalysis.Threading.AsyncBatchingWorkQueue`2._nextBatch"/>. These
            tasks form a chain so that the next task only processes when the previous one completes.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Threading.AsyncBatchingWorkQueue`2._taskInFlight">
            <summary>
            Whether or not there is an existing task in flight that will process the current batch
            of <see cref="F:Microsoft.CodeAnalysis.Threading.AsyncBatchingWorkQueue`2._nextBatch"/>.  If there is an existing in flight task, we don't need to
            kick off a new one if we receive more work before it runs.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Threading.AsyncBatchingWorkQueue`2.#ctor(System.TimeSpan,System.Func{Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList{`0},System.Threading.CancellationToken,System.Threading.Tasks.ValueTask{`1}},System.Collections.Generic.IEqualityComparer{`0},Microsoft.CodeAnalysis.Shared.TestHooks.IAsynchronousOperationListener,System.Threading.CancellationToken)">
            <param name="processBatchAsync">Callback to process queued work items.  The list of items passed in is
            guaranteed to always be non-empty.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Threading.AsyncBatchingWorkQueue`2.CancelExistingWork">
            <summary>
            Cancels any outstanding work in this queue.  Work that has not yet started will never run. Work that is in
            progress will request cancellation in a standard best effort fashion.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Threading.AsyncBatchingWorkQueue`2.WaitUntilCurrentBatchCompletesAsync">
            <summary>
            Waits until the current batch of work completes and returns the last value successfully computed from <see
            cref="F:Microsoft.CodeAnalysis.Threading.AsyncBatchingWorkQueue`2._processBatchAsync"/>.  If the last <see cref="F:Microsoft.CodeAnalysis.Threading.AsyncBatchingWorkQueue`2._processBatchAsync"/> canceled or failed, then a
            corresponding canceled or faulted task will be returned that propagates that outwards.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Threading.CancellationSeries">
            <summary>
            Produces a series of <see cref="T:System.Threading.CancellationToken"/> objects such that requesting a new token
            causes the previously issued token to be cancelled.
            </summary>
            <remarks>
            <para>Consuming code is responsible for managing overlapping asynchronous operations.</para>
            <para>This class has a lock-free implementation to minimise latency and contention.</para>
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Threading.CancellationSeries.#ctor(System.Threading.CancellationToken)">
            <summary>
            Initializes a new instance of <see cref="T:Microsoft.CodeAnalysis.Threading.CancellationSeries"/>.
            </summary>
            <param name="token">An optional cancellation token that, when cancelled, cancels the last
            issued token and causes any subsequent tokens to be issued in a cancelled state.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Threading.CancellationSeries.HasActiveToken">
            <summary>
            Determines if the cancellation series has an active token which has not been cancelled.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Threading.CancellationSeries.CreateNext(System.Threading.CancellationToken)">
            <summary>
            Creates the next <see cref="T:System.Threading.CancellationToken"/> in the series, ensuring the last issued
            token (if any) is cancelled first.
            </summary>
            <param name="token">An optional cancellation token that, when cancelled, cancels the
            returned token.</param>
            <returns>
            A cancellation token that will be cancelled when either:
            <list type="bullet">
            <item><see cref="M:Microsoft.CodeAnalysis.Threading.CancellationSeries.CreateNext(System.Threading.CancellationToken)"/> is called again</item>
            <item>The token passed to this method (if any) is cancelled</item>
            <item>The token passed to the constructor (if any) is cancelled</item>
            <item><see cref="M:Microsoft.CodeAnalysis.Threading.CancellationSeries.Dispose"/> is called</item>
            </list>
            </returns>
            <exception cref="T:System.ObjectDisposedException">This object has been disposed.</exception>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Threading.ConfiguredYieldAwaitable">
            <summary>
            A custom awaiter that supports <see cref="M:Microsoft.CodeAnalysis.Threading.YieldAwaitableExtensions.ConfigureAwait(System.Runtime.CompilerServices.YieldAwaitable,System.Boolean)"/> for
            <see cref="M:System.Threading.Tasks.Task.Yield"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Threading.TaskExtensions.NoThrowAwaitableInternal(System.Threading.Tasks.Task,System.Boolean)">
            <summary>
            Returns an awaitable for the specified task that will never throw, even if the source task
            faults or is canceled.
            </summary>
            <param name="task">The task whose completion should signal the completion of the returned awaitable.</param>
            <param name="captureContext">if set to <c>true</c> the continuation will be scheduled on the caller's context; <c>false</c> to always execute the continuation on the threadpool.</param>
            <returns>An awaitable.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Threading.TaskExtensions.NoThrowTaskAwaitable">
            <summary>
            An awaitable that wraps a task and never throws an exception when waited on.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Threading.TaskExtensions.NoThrowTaskAwaitable._task">
            <summary>
            The task.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Threading.TaskExtensions.NoThrowTaskAwaitable._captureContext">
            <summary>
            A value indicating whether the continuation should be scheduled on the current sync context.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Threading.TaskExtensions.NoThrowTaskAwaitable.#ctor(System.Threading.Tasks.Task,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.CodeAnalysis.Threading.TaskExtensions.NoThrowTaskAwaitable" /> struct.
            </summary>
            <param name="task">The task.</param>
            <param name="captureContext">Whether the continuation should be scheduled on the current sync context.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Threading.TaskExtensions.NoThrowTaskAwaitable.GetAwaiter">
            <summary>
            Gets the awaiter.
            </summary>
            <returns>The awaiter.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Threading.TaskExtensions.NoThrowTaskAwaiter">
            <summary>
            An awaiter that wraps a task and never throws an exception when waited on.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Threading.TaskExtensions.NoThrowTaskAwaiter._task">
            <summary>
            The task.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Threading.TaskExtensions.NoThrowTaskAwaiter._captureContext">
            <summary>
            A value indicating whether the continuation should be scheduled on the current sync context.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Threading.TaskExtensions.NoThrowTaskAwaiter.#ctor(System.Threading.Tasks.Task,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.CodeAnalysis.Threading.TaskExtensions.NoThrowTaskAwaiter"/> struct.
            </summary>
            <param name="task">The task.</param>
            <param name="captureContext">if set to <c>true</c> [capture context].</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Threading.TaskExtensions.NoThrowTaskAwaiter.IsCompleted">
            <summary>
            Gets a value indicating whether the task has completed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Threading.TaskExtensions.NoThrowTaskAwaiter.OnCompleted(System.Action)">
            <summary>
            Schedules a delegate for execution at the conclusion of a task's execution.
            </summary>
            <param name="continuation">The action.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Threading.TaskExtensions.NoThrowTaskAwaiter.UnsafeOnCompleted(System.Action)">
            <summary>
            Schedules a delegate for execution at the conclusion of a task's execution
            without capturing the ExecutionContext.
            </summary>
            <param name="continuation">The action.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Threading.TaskExtensions.NoThrowTaskAwaiter.GetResult">
            <summary>
            Does nothing.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Threading.ValueTaskExtensions.NoThrowAwaitableInternal(System.Threading.Tasks.ValueTask,System.Boolean)">
            <summary>
            Returns an awaitable for the specified task that will never throw, even if the source task
            faults or is canceled.
            </summary>
            <param name="task">The task whose completion should signal the completion of the returned awaitable.</param>
            <param name="captureContext">if set to <see langword="true"/> the continuation will be scheduled on the caller's context; <see langword="false"/> to always execute the continuation on the threadpool.</param>
            <returns>An awaitable.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Threading.ValueTaskExtensions.NoThrowAwaitableInternal``1(System.Threading.Tasks.ValueTask{``0},System.Boolean)">
             <summary>
             Returns an awaitable for the specified task that will never throw, even if the source task
             faults or is canceled.
             </summary>
             <remarks>
             The awaitable returned by this method does not provide access to the result of a successfully-completed
             <see cref="T:System.Threading.Tasks.ValueTask`1"/>. To await without throwing and use the resulting value, the following
             pattern may be used:
            
             <code>
             var methodValueTask = MethodAsync().Preserve();
             await methodValueTask.NoThrowAwaitableInternal(true);
             if (methodValueTask.IsCompletedSuccessfully)
             {
               var result = methodValueTask.Result;
             }
             else
             {
               var exception = methodValueTask.AsTask().Exception.InnerException;
             }
             </code>
             </remarks>
             <param name="task">The task whose completion should signal the completion of the returned awaitable.</param>
             <param name="captureContext">if set to <see langword="true"/> the continuation will be scheduled on the caller's context; <see langword="false"/> to always execute the continuation on the threadpool.</param>
             <returns>An awaitable.</returns>
             <typeparam name="TResult">The type of the result.</typeparam>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Threading.ValueTaskExtensions.NoThrowValueTaskAwaitable">
            <summary>
            An awaitable that wraps a task and never throws an exception when waited on.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Threading.ValueTaskExtensions.NoThrowValueTaskAwaitable._task">
            <summary>
            The task.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Threading.ValueTaskExtensions.NoThrowValueTaskAwaitable._captureContext">
            <summary>
            A value indicating whether the continuation should be scheduled on the current sync context.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Threading.ValueTaskExtensions.NoThrowValueTaskAwaitable.#ctor(System.Threading.Tasks.ValueTask,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.CodeAnalysis.Threading.ValueTaskExtensions.NoThrowValueTaskAwaitable"/> struct.
            </summary>
            <param name="task">The task.</param>
            <param name="captureContext">Whether the continuation should be scheduled on the current sync context.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Threading.ValueTaskExtensions.NoThrowValueTaskAwaitable.GetAwaiter">
            <summary>
            Gets the awaiter.
            </summary>
            <returns>The awaiter.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Threading.ValueTaskExtensions.NoThrowValueTaskAwaiter">
            <summary>
            An awaiter that wraps a task and never throws an exception when waited on.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Threading.ValueTaskExtensions.NoThrowValueTaskAwaiter._task">
            <summary>
            The task.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Threading.ValueTaskExtensions.NoThrowValueTaskAwaiter._captureContext">
            <summary>
            A value indicating whether the continuation should be scheduled on the current sync context.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Threading.ValueTaskExtensions.NoThrowValueTaskAwaiter.#ctor(System.Threading.Tasks.ValueTask,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.CodeAnalysis.Threading.ValueTaskExtensions.NoThrowValueTaskAwaiter"/> struct.
            </summary>
            <param name="task">The task.</param>
            <param name="captureContext">if set to <see langword="true"/> [capture context].</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Threading.ValueTaskExtensions.NoThrowValueTaskAwaiter.IsCompleted">
            <summary>
            Gets a value indicating whether the task has completed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Threading.ValueTaskExtensions.NoThrowValueTaskAwaiter.OnCompleted(System.Action)">
            <summary>
            Schedules a delegate for execution at the conclusion of a task's execution.
            </summary>
            <param name="continuation">The action.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Threading.ValueTaskExtensions.NoThrowValueTaskAwaiter.UnsafeOnCompleted(System.Action)">
            <summary>
            Schedules a delegate for execution at the conclusion of a task's execution
            without capturing the ExecutionContext.
            </summary>
            <param name="continuation">The action.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Threading.ValueTaskExtensions.NoThrowValueTaskAwaiter.GetResult">
            <summary>
            Does nothing.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Threading.ValueTaskExtensions.NoThrowValueTaskAwaitable`1">
            <summary>
            An awaitable that wraps a <see cref="T:System.Threading.Tasks.ValueTask`1"/> and never throws an exception when waited on.
            </summary>
            <typeparam name="TResult">The type of the result.</typeparam>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Threading.ValueTaskExtensions.NoThrowValueTaskAwaitable`1._task">
            <summary>
            The task.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Threading.ValueTaskExtensions.NoThrowValueTaskAwaitable`1._captureContext">
            <summary>
            A value indicating whether the continuation should be scheduled on the current sync context.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Threading.ValueTaskExtensions.NoThrowValueTaskAwaitable`1.#ctor(System.Threading.Tasks.ValueTask{`0},System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.CodeAnalysis.Threading.ValueTaskExtensions.NoThrowValueTaskAwaitable`1" /> struct.
            </summary>
            <param name="task">The task.</param>
            <param name="captureContext">Whether the continuation should be scheduled on the current sync context.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Threading.ValueTaskExtensions.NoThrowValueTaskAwaitable`1.GetAwaiter">
            <summary>
            Gets the awaiter.
            </summary>
            <returns>The awaiter.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Threading.ValueTaskExtensions.NoThrowValueTaskAwaiter`1">
            <summary>
            An awaiter that wraps a task and never throws an exception when waited on.
            </summary>
            <typeparam name="TResult">The type of the result.</typeparam>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Threading.ValueTaskExtensions.NoThrowValueTaskAwaiter`1._task">
            <summary>
            The task.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Threading.ValueTaskExtensions.NoThrowValueTaskAwaiter`1._captureContext">
            <summary>
            A value indicating whether the continuation should be scheduled on the current sync context.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Threading.ValueTaskExtensions.NoThrowValueTaskAwaiter`1.#ctor(System.Threading.Tasks.ValueTask{`0},System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.CodeAnalysis.Threading.ValueTaskExtensions.NoThrowValueTaskAwaiter`1"/> struct.
            </summary>
            <param name="task">The task.</param>
            <param name="captureContext">if set to <see langword="true"/> [capture context].</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Threading.ValueTaskExtensions.NoThrowValueTaskAwaiter`1.IsCompleted">
            <summary>
            Gets a value indicating whether the task has completed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Threading.ValueTaskExtensions.NoThrowValueTaskAwaiter`1.OnCompleted(System.Action)">
            <summary>
            Schedules a delegate for execution at the conclusion of a task's execution.
            </summary>
            <param name="continuation">The action.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Threading.ValueTaskExtensions.NoThrowValueTaskAwaiter`1.UnsafeOnCompleted(System.Action)">
            <summary>
            Schedules a delegate for execution at the conclusion of a task's execution
            without capturing the ExecutionContext.
            </summary>
            <param name="continuation">The action.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Threading.ValueTaskExtensions.NoThrowValueTaskAwaiter`1.GetResult">
            <summary>
            Does nothing.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Threading.VoidResult">
            <summary>
            Explicitly indicates result is void
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Threading.YieldAwaitableExtensions.ConfigureAwait(System.Runtime.CompilerServices.YieldAwaitable,System.Boolean)">
            <summary>
            Implements <c>ConfigureAwait(bool)</c> for <see cref="M:System.Threading.Tasks.Task.Yield"/>. The resulting behavior in asynchronous code
            is the same as one would expect for <see cref="M:System.Threading.Tasks.Task.ConfigureAwait(System.Boolean)"/>.
            </summary>
            <param name="awaitable">The awaitable provided by <see cref="M:System.Threading.Tasks.Task.Yield"/>.</param>
            <param name="continueOnCapturedContext"><inheritdoc cref="M:System.Threading.Tasks.Task.ConfigureAwait(System.Boolean)"/></param>
            <returns>An object used to await this yield.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.TestHooks.IExpeditableDelaySource.Delay(System.TimeSpan,System.Threading.CancellationToken)">
            <summary>
            Creates a task that will complete after a time delay, but can be expedited if an operation is waiting for
            the task to complete.
            </summary>
            <param name="delay">The time to wait before completing the returned task, or <c>TimeSpan.FromMilliseconds(-1)</c> to wait indefinitely.</param>
            <param name="cancellationToken">A cancellation token to observe while waiting for the task to complete.</param>
            <returns><see langword="true"/> if the delay compeleted normally; otherwise, <see langword="false"/> if the delay completed due to a request to expedite the delay.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <para><paramref name="delay"/> represents a negative time interval other than <c>TimeSpan.FromMilliseconds(-1)</c>.</para>
            <para>-or-</para>
            <para>The <paramref name="delay"/> argument's <see cref="P:System.TimeSpan.TotalMilliseconds"/> property is greater than <see cref="F:System.Int32.MaxValue"/>.</para>
            </exception>
            <exception cref="T:System.OperationCanceledException">The delay has been canceled.</exception>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Shared.TestHooks.IAsynchronousOperationListenerProvider">
            <summary>
            Return <see cref="T:Microsoft.CodeAnalysis.Shared.TestHooks.IAsynchronousOperationListener"/> for the given featureName
            
            We have this abstraction so that we can have isolated listener/waiter in unit tests
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.TestHooks.IAsynchronousOperationListenerProvider.GetListener(System.String)">
            <summary>
            Get <see cref="T:Microsoft.CodeAnalysis.Shared.TestHooks.IAsynchronousOperationListener"/> for given feature.
            same provider will return a singleton listener for same feature
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary">
            <summary>
            Provides methods for creating a segmented dictionary that is immutable; meaning it cannot be changed once it is
            created.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2">
             <summary>
             Represents a segmented dictionary that is immutable; meaning it cannot be changed once it is created.
             </summary>
             <remarks>
             <para>There are different scenarios best for <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2"/> and others
             best for <see cref="T:System.Collections.Immutable.ImmutableDictionary`2"/>.</para>
            
             <para>In general, <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2"/> is applicable in scenarios most like
             the scenarios where <see cref="T:System.Collections.Immutable.ImmutableArray`1"/> is applicable, and
             <see cref="T:System.Collections.Immutable.ImmutableDictionary`2"/> is applicable in scenarios most like the scenarios where
             <see cref="T:System.Collections.Immutable.ImmutableList`1"/> is applicable.</para>
            
             <para>The following table summarizes the performance characteristics of
             <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2"/>:</para>
             
             <list type="table">
               <item>
                 <description>Operation</description>
                 <description><see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2"/> Complexity</description>
                 <description><see cref="T:System.Collections.Immutable.ImmutableDictionary`2"/> Complexity</description>
                 <description>Comments</description>
               </item>
               <item>
                 <description>Item</description>
                 <description>O(1)</description>
                 <description>O(log n)</description>
                 <description>Directly index into the underlying segmented dictionary</description>
               </item>
               <item>
                 <description>Add()</description>
                 <description>O(n)</description>
                 <description>O(log n)</description>
                 <description>Requires creating a new segmented dictionary</description>
               </item>
             </list>
             
             <para>This type is backed by segmented arrays to avoid using the Large Object Heap without impacting algorithmic
             complexity.</para>
             </remarks>
             <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
             <typeparam name="TValue">The type of the values in the dictionary.</typeparam>
             <devremarks>
             <para>This type has a documented contract of being exactly one reference-type field in size. Our own
             <see cref="T:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked"/> class depends on it, as well as others externally.</para>
            
             <para><strong>IMPORTANT NOTICE FOR MAINTAINERS AND REVIEWERS:</strong></para>
            
             <para>This type should be thread-safe. As a struct, it cannot protect its own fields from being changed from one
             thread while its members are executing on other threads because structs can change <em>in place</em> simply by
             reassigning the field containing this struct. Therefore it is extremely important that <strong> Every member
             should only dereference <c>this</c> ONCE </strong>. If a member needs to reference the
             <see cref="F:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2._dictionary"/> field, that counts as a dereference of <c>this</c>. Calling other instance members
             (properties or methods) also counts as dereferencing <c>this</c>. Any member that needs to use <c>this</c> more
             than once must instead assign <c>this</c> to a local variable and use that for the rest of the code instead.
             This effectively copies the one field in the struct to a local variable so that it is insulated from other
             threads.</para>
             </devremarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2.Builder.PrivateMarshal">
            <summary>
            Private helper class for use only by <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedCollectionsMarshal"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2.Builder.PrivateMarshal.FindValue(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{`0,`1}.Builder,`0)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.Collections.SegmentedCollectionsMarshal.GetValueRefOrNullRef``2(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1}.Builder,``0)"/>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2.Builder._builder">
            <summary>
            The private builder implementation.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2.Enumerator.ReturnType.KeyValuePair">
            <summary>
            The return value from the implementation of <see cref="M:System.Collections.IEnumerable.GetEnumerator"/> is
            <see cref="T:System.Collections.Generic.KeyValuePair`2"/>. This is the return value for most instances of this
            enumerator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2.Enumerator.ReturnType.DictionaryEntry">
            <summary>
            The return value from the implementation of <see cref="M:System.Collections.IEnumerable.GetEnumerator"/> is
            <see cref="T:System.Collections.DictionaryEntry"/>. This is the return value for instances of this
            enumerator created by the <see cref="M:System.Collections.IDictionary.GetEnumerator"/> implementation in
            <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2.PrivateMarshal">
            <summary>
            Private helper class for use only by <see cref="T:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked"/> and
            <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedCollectionsMarshal"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2.PrivateMarshal.FindValue(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{`0,`1},`0)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.Collections.SegmentedCollectionsMarshal.GetValueRefOrNullRef``2(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1},``0)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2.PrivateMarshal.AsImmutableSegmentedDictionary(Microsoft.CodeAnalysis.Collections.SegmentedDictionary{`0,`1})">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.Collections.SegmentedCollectionsMarshal.AsImmutableSegmentedDictionary``2(Microsoft.CodeAnalysis.Collections.SegmentedDictionary{``0,``1})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2.PrivateMarshal.AsSegmentedDictionary(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{`0,`1})">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.Collections.SegmentedCollectionsMarshal.AsSegmentedDictionary``2(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1})"/>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2.ValueBuilder._dictionary">
            <summary>
            The immutable collection this builder is based on.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2.ValueBuilder._mutableDictionary">
            <summary>
            The current mutable collection this builder is operating on. This field is initialized to a copy of
            <see cref="F:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2.ValueBuilder._dictionary"/> the first time a change is made.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet.Create``1">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet.Create``1"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet.Create``1(``0)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet.Create``1(``0)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet.Create``1(``0[])">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet.Create``1(``0[])"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet.Create``1(System.Collections.Generic.IEqualityComparer{``0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet.Create``1(System.Collections.Generic.IEqualityComparer{``0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet.Create``1(System.Collections.Generic.IEqualityComparer{``0},``0)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet.Create``1(System.Collections.Generic.IEqualityComparer{``0},``0)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet.Create``1(System.Collections.Generic.IEqualityComparer{``0},``0[])">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet.Create``1(System.Collections.Generic.IEqualityComparer{``0},``0[])"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet.CreateBuilder``1">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet.CreateBuilder``1"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet.CreateBuilder``1(System.Collections.Generic.IEqualityComparer{``0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet.CreateBuilder``1(System.Collections.Generic.IEqualityComparer{``0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet.CreateRange``1(System.Collections.Generic.IEnumerable{``0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet.CreateRange``1(System.Collections.Generic.IEnumerable{``0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet.CreateRange``1(System.Collections.Generic.IEqualityComparer{``0},System.Collections.Generic.IEnumerable{``0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet.CreateRange``1(System.Collections.Generic.IEqualityComparer{``0},System.Collections.Generic.IEnumerable{``0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet.ToImmutableSegmentedHashSet``1(System.Collections.Generic.IEnumerable{``0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet.ToImmutableHashSet``1(System.Collections.Generic.IEnumerable{``0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet.ToImmutableSegmentedHashSet``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet.ToImmutableHashSet``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet.ToImmutableSegmentedHashSet``1(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet{``0}.Builder)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet.ToImmutableHashSet``1(System.Collections.Immutable.ImmutableHashSet{``0}.Builder)"/>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1">
             <summary>
             Represents a segmented hash set that is immutable; meaning it cannot be changed once it is created.
             </summary>
             <remarks>
             <para>There are different scenarios best for <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1"/> and others
             best for <see cref="T:System.Collections.Immutable.ImmutableHashSet`1"/>.</para>
            
             <para>The following table summarizes the performance characteristics of
             <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1"/>:</para>
             
             <list type="table">
               <item>
                 <description>Operation</description>
                 <description><see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1"/> Complexity</description>
                 <description><see cref="T:System.Collections.Immutable.ImmutableHashSet`1"/> Complexity</description>
                 <description>Comments</description>
               </item>
               <item>
                 <description>Contains</description>
                 <description>O(1)</description>
                 <description>O(log n)</description>
                 <description>Directly index into the underlying segmented list</description>
               </item>
               <item>
                 <description>Add()</description>
                 <description>O(n)</description>
                 <description>O(log n)</description>
                 <description>Requires creating a new segmented hash set and cloning all impacted segments</description>
               </item>
             </list>
             
             <para>This type is backed by segmented arrays to avoid using the Large Object Heap without impacting algorithmic
             complexity.</para>
             </remarks>
             <typeparam name="T">The type of the value in the set.</typeparam>
             <devremarks>
             <para>This type has a documented contract of being exactly one reference-type field in size. Our own
             <see cref="T:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked"/> class depends on it, as well as others externally.</para>
            
             <para><strong>IMPORTANT NOTICE FOR MAINTAINERS AND REVIEWERS:</strong></para>
            
             <para>This type should be thread-safe. As a struct, it cannot protect its own fields from being changed from one
             thread while its members are executing on other threads because structs can change <em>in place</em> simply by
             reassigning the field containing this struct. Therefore it is extremely important that <strong> Every member
             should only dereference <c>this</c> ONCE </strong>. If a member needs to reference the
             <see cref="F:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1._set"/> field, that counts as a dereference of <c>this</c>. Calling other instance members
             (properties or methods) also counts as dereferencing <c>this</c>. Any member that needs to use <c>this</c> more
             than once must instead assign <c>this</c> to a local variable and use that for the rest of the code instead.
             This effectively copies the one field in the struct to a local variable so that it is insulated from other
             threads.</para>
             </devremarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Builder._builder">
            <summary>
            The private builder implementation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Builder.KeyComparer">
            <inheritdoc cref="P:System.Collections.Immutable.ImmutableHashSet`1.Builder.KeyComparer"/>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Builder.Count">
            <inheritdoc cref="P:System.Collections.Immutable.ImmutableHashSet`1.Builder.Count"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Builder.Add(`0)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.Add(`0)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Builder.Clear">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.Clear"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Builder.Contains(`0)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.Contains(`0)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Builder.ExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.ExceptWith(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Builder.GetEnumerator">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.GetEnumerator"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Builder.IntersectWith(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.IntersectWith(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Builder.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Builder.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Builder.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Builder.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Builder.Overlaps(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.Overlaps(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Builder.Remove(`0)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.Remove(`0)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Builder.SetEquals(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.SetEquals(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Builder.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Builder.TryGetValue(`0,`0@)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.TryGetValue(`0,`0@)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Builder.UnionWith(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.UnionWith(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Builder.ToImmutable">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.ToImmutable"/>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Enumerator">
            <inheritdoc cref="T:System.Collections.Immutable.ImmutableHashSet`1.Enumerator"/>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Enumerator.Current">
            <inheritdoc cref="P:System.Collections.Immutable.ImmutableHashSet`1.Enumerator.Current"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Enumerator.Dispose">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Enumerator.Dispose"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Enumerator.MoveNext">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Enumerator.MoveNext"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Enumerator.Reset">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Enumerator.Reset"/>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.PrivateMarshal">
            <summary>
            Private helper class for use only by <see cref="T:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked"/> and
            <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedCollectionsMarshal"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.PrivateMarshal.AsImmutableSegmentedHashSet(Microsoft.CodeAnalysis.Collections.SegmentedHashSet{`0})">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.Collections.SegmentedCollectionsMarshal.AsImmutableSegmentedHashSet``1(Microsoft.CodeAnalysis.Collections.SegmentedHashSet{``0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.PrivateMarshal.AsSegmentedHashSet(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet{`0})">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.Collections.SegmentedCollectionsMarshal.AsSegmentedHashSet``1(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet{``0})"/>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.ValueBuilder._set">
            <summary>
            The immutable collection this builder is based on.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.ValueBuilder._mutableSet">
            <summary>
            The current mutable collection this builder is operating on. This field is initialized to a copy of
            <see cref="F:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.ValueBuilder._set"/> the first time a change is made.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.ValueBuilder.KeyComparer">
            <inheritdoc cref="P:System.Collections.Immutable.ImmutableHashSet`1.Builder.KeyComparer"/>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.ValueBuilder.Count">
            <inheritdoc cref="P:System.Collections.Immutable.ImmutableHashSet`1.Builder.Count"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.ValueBuilder.Add(`0)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.Add(`0)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.ValueBuilder.Clear">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.Clear"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.ValueBuilder.Contains(`0)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.Contains(`0)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.ValueBuilder.ExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.ExceptWith(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.ValueBuilder.GetEnumerator">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.GetEnumerator"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.ValueBuilder.IntersectWith(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.IntersectWith(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.ValueBuilder.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.ValueBuilder.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.ValueBuilder.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.ValueBuilder.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.ValueBuilder.Overlaps(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.Overlaps(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.ValueBuilder.Remove(`0)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.Remove(`0)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.ValueBuilder.SetEquals(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.SetEquals(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.ValueBuilder.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.ValueBuilder.TryGetValue(`0,`0@)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.TryGetValue(`0,`0@)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.ValueBuilder.UnionWith(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.UnionWith(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.ValueBuilder.ToImmutable">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.ToImmutable"/>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Empty">
            <inheritdoc cref="F:System.Collections.Immutable.ImmutableHashSet`1.Empty"/>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.KeyComparer">
            <inheritdoc cref="P:System.Collections.Immutable.ImmutableHashSet`1.KeyComparer"/>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Count">
            <inheritdoc cref="P:System.Collections.Immutable.ImmutableHashSet`1.Count"/>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.IsEmpty">
            <inheritdoc cref="P:System.Collections.Immutable.ImmutableHashSet`1.IsEmpty"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Add(`0)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Add(`0)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Clear">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Clear"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Contains(`0)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Contains(`0)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Except(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Except(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.GetEnumerator">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.GetEnumerator"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Intersect(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Intersect(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Remove(`0)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Remove(`0)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.SymmetricExcept(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.SymmetricExcept(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.TryGetValue(`0,`0@)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.TryGetValue(`0,`0@)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Union(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Union(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.ToBuilder">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.ToBuilder"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.WithComparer(System.Collections.Generic.IEqualityComparer{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.WithComparer(System.Collections.Generic.IEqualityComparer{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList.Create``1">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList.Create``1"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList.Create``1(``0)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList.Create``1(``0)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList.Create``1(``0[])">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList.Create``1(``0[])"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList.CreateBuilder``1">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList.CreateBuilder``1"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList.CreateRange``1(System.Collections.Generic.IEnumerable{``0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList.CreateRange``1(System.Collections.Generic.IEnumerable{``0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList.ToImmutableSegmentedList``1(System.Collections.Generic.IEnumerable{``0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList.ToImmutableList``1(System.Collections.Generic.IEnumerable{``0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList.ToImmutableSegmentedList``1(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList{``0}.Builder)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList.ToImmutableList``1(System.Collections.Immutable.ImmutableList{``0}.Builder)"/>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1">
             <summary>
             Represents a segmented list that is immutable; meaning it cannot be changed once it is created.
             </summary>
             <remarks>
             <para>There are different scenarios best for <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1"/> and others
             best for <see cref="T:System.Collections.Immutable.ImmutableList`1"/>.</para>
            
             <para>The following table summarizes the performance characteristics of
             <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1"/>:</para>
             
             <list type="table">
               <item>
                 <description>Operation</description>
                 <description><see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1"/> Complexity</description>
                 <description><see cref="T:System.Collections.Immutable.ImmutableList`1"/> Complexity</description>
                 <description>Comments</description>
               </item>
               <item>
                 <description>Item</description>
                 <description>O(1)</description>
                 <description>O(log n)</description>
                 <description>Directly index into the underlying segmented list</description>
               </item>
               <item>
                 <description>Add()</description>
                 <description>Currently O(n), but could be O(1) with a relatively large constant</description>
                 <description>O(log n)</description>
                 <description>Currently requires creating a new segmented list, but could be modified to only clone the segments with changes</description>
               </item>
               <item>
                 <description>Insert()</description>
                 <description>O(n)</description>
                 <description>O(log n)</description>
                 <description>Requires creating a new segmented list and cloning all impacted segments</description>
               </item>
             </list>
             
             <para>This type is backed by segmented arrays to avoid using the Large Object Heap without impacting algorithmic
             complexity.</para>
             </remarks>
             <typeparam name="T">The type of the value in the list.</typeparam>
             <devremarks>
             <para>This type has a documented contract of being exactly one reference-type field in size. Our own
             <see cref="T:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked"/> class depends on it, as well as others externally.</para>
            
             <para><strong>IMPORTANT NOTICE FOR MAINTAINERS AND REVIEWERS:</strong></para>
            
             <para>This type should be thread-safe. As a struct, it cannot protect its own fields from being changed from one
             thread while its members are executing on other threads because structs can change <em>in place</em> simply by
             reassigning the field containing this struct. Therefore it is extremely important that <strong> Every member
             should only dereference <c>this</c> ONCE </strong>. If a member needs to reference the
             <see cref="F:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1._list"/> field, that counts as a dereference of <c>this</c>. Calling other instance members
             (properties or methods) also counts as dereferencing <c>this</c>. Any member that needs to use <c>this</c> more
             than once must instead assign <c>this</c> to a local variable and use that for the rest of the code instead.
             This effectively copies the one field in the struct to a local variable so that it is insulated from other
             threads.</para>
             </devremarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder._builder">
            <summary>
            The private builder implementation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.ItemRef(System.Int32)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.ItemRef(System.Int32)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.AddRange(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.BinarySearch(`0)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.BinarySearch(`0)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.BinarySearch(`0,System.Collections.Generic.IComparer{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.BinarySearch(`0,System.Collections.Generic.IComparer{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.ConvertAll``1(System.Converter{`0,``0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.ConvertAll``1(System.Func{`0,``0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.CopyTo(`0[])">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.CopyTo(`0[])"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.CopyTo(System.Int32,`0[],System.Int32,System.Int32)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.CopyTo(System.Int32,`0[],System.Int32,System.Int32)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.Exists(System.Predicate{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.Exists(System.Predicate{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.Find(System.Predicate{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.Find(System.Predicate{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.FindAll(System.Predicate{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.FindAll(System.Predicate{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.FindIndex(System.Predicate{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.FindIndex(System.Predicate{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.FindIndex(System.Int32,System.Predicate{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.FindIndex(System.Int32,System.Predicate{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.FindIndex(System.Int32,System.Int32,System.Predicate{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.FindIndex(System.Int32,System.Int32,System.Predicate{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.FindLast(System.Predicate{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.FindLast(System.Predicate{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.FindLastIndex(System.Predicate{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.FindLastIndex(System.Predicate{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.FindLastIndex(System.Int32,System.Predicate{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.FindLastIndex(System.Int32,System.Predicate{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.ForEach(System.Action{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.ForEach(System.Action{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.GetEnumerator">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.GetEnumerator"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.GetRange(System.Int32,System.Int32)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.GetRange(System.Int32,System.Int32)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.IndexOf(`0,System.Int32)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.IndexOf(`0,System.Int32)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.IndexOf(`0,System.Int32,System.Int32)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.IndexOf(`0,System.Int32,System.Int32)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.IndexOf(`0,System.Int32,System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.IndexOf(`0,System.Int32,System.Int32,System.Collections.Generic.IEqualityComparer{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.LastIndexOf(`0)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.LastIndexOf(`0)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.LastIndexOf(`0,System.Int32)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.LastIndexOf(`0,System.Int32)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.LastIndexOf(`0,System.Int32,System.Int32)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.LastIndexOf(`0,System.Int32,System.Int32)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.LastIndexOf(`0,System.Int32,System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.LastIndexOf(`0,System.Int32,System.Int32,System.Collections.Generic.IEqualityComparer{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.RemoveAll(System.Predicate{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.RemoveAll(System.Predicate{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.Reverse">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.Reverse"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.Reverse(System.Int32,System.Int32)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.Reverse(System.Int32,System.Int32)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.Sort">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.Sort"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.Sort(System.Collections.Generic.IComparer{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.Sort(System.Collections.Generic.IComparer{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.Sort(System.Comparison{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.Sort(System.Comparison{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.ToImmutable">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.ToImmutable"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.TrueForAll(System.Predicate{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.TrueForAll(System.Predicate{`0})"/>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.PrivateMarshal">
            <summary>
            Private helper class for use only by <see cref="T:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked"/> and
            <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedCollectionsMarshal"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.PrivateMarshal.AsImmutableSegmentedList(Microsoft.CodeAnalysis.Collections.SegmentedList{`0})">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.Collections.SegmentedCollectionsMarshal.AsImmutableSegmentedList``1(Microsoft.CodeAnalysis.Collections.SegmentedList{``0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.PrivateMarshal.AsSegmentedList(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList{`0})">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.Collections.SegmentedCollectionsMarshal.AsSegmentedList``1(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList{``0})"/>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.ValueBuilder._list">
            <summary>
            The immutable collection this builder is based on.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.ValueBuilder._mutableList">
            <summary>
            The current mutable collection this builder is operating on. This field is initialized to a copy of
            <see cref="F:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.ValueBuilder._list"/> the first time a change is made.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Empty">
            <inheritdoc cref="F:System.Collections.Immutable.ImmutableList`1.Empty"/>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.IsEmpty">
            <inheritdoc cref="P:System.Collections.Immutable.ImmutableList`1.IsEmpty"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.ItemRef(System.Int32)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.ItemRef(System.Int32)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Add(`0)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Add(`0)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.AddRange(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.BinarySearch(`0)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.BinarySearch(`0)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Clear">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Clear"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.ConvertAll``1(System.Converter{`0,``0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.ConvertAll``1(System.Func{`0,``0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.CopyTo(`0[])">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.CopyTo(`0[])"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.CopyTo(System.Int32,`0[],System.Int32,System.Int32)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.CopyTo(System.Int32,`0[],System.Int32,System.Int32)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Exists(System.Predicate{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Exists(System.Predicate{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Find(System.Predicate{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Find(System.Predicate{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.FindAll(System.Predicate{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.FindAll(System.Predicate{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.FindIndex(System.Predicate{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.FindIndex(System.Predicate{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.FindIndex(System.Int32,System.Predicate{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.FindIndex(System.Int32,System.Predicate{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.FindIndex(System.Int32,System.Int32,System.Predicate{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.FindIndex(System.Int32,System.Int32,System.Predicate{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.FindLast(System.Predicate{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.FindLast(System.Predicate{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.FindLastIndex(System.Predicate{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.FindLastIndex(System.Predicate{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.FindLastIndex(System.Int32,System.Predicate{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.FindLastIndex(System.Int32,System.Predicate{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.ForEach(System.Action{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.ForEach(System.Action{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.GetEnumerator">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.GetEnumerator"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.GetRange(System.Int32,System.Int32)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.GetRange(System.Int32,System.Int32)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Insert(System.Int32,`0)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Insert(System.Int32,`0)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Remove(`0)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Remove(`0)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Remove(`0,System.Collections.Generic.IEqualityComparer{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Remove(`0,System.Collections.Generic.IEqualityComparer{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.RemoveAll(System.Predicate{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.RemoveAll(System.Predicate{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.RemoveAt(System.Int32)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.RemoveAt(System.Int32)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.RemoveRange(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.RemoveRange(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.RemoveRange(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.RemoveRange(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.RemoveRange(System.Int32,System.Int32)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.RemoveRange(System.Int32,System.Int32)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Replace(`0,`0)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Replace(`0,`0)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Replace(`0,`0,System.Collections.Generic.IEqualityComparer{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Replace(`0,`0,System.Collections.Generic.IEqualityComparer{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Reverse">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Reverse"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Reverse(System.Int32,System.Int32)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Reverse(System.Int32,System.Int32)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.SetItem(System.Int32,`0)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.SetItem(System.Int32,`0)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Sort">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Sort"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Sort(System.Collections.Generic.IComparer{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Sort(System.Collections.Generic.IComparer{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Sort(System.Comparison{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Sort(System.Comparison{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.ToBuilder">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.ToBuilder"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.TrueForAll(System.Predicate{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.TrueForAll(System.Predicate{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.Internal.SegmentedGenericArraySortHelper`1.SwapIfGreater(`0@,`0@)">
            <summary>Swaps the values in the two references if the first is greater than the second.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.Internal.SegmentedGenericArraySortHelper`1.Swap(`0@,`0@)">
            <summary>Swaps the values in the two references, regardless of whether the two references are the same.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Collections.Internal.SegmentedArraySortUtils">
            <summary>Helper methods for use in array/span sorting routines.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.Internal.SegmentedArraySortUtils.Log2SoftwareFallback(System.UInt32)">
            <summary>
            Returns the integer (floor) log of the specified value, base 2.
            Note that by convention, input value 0 returns 0 since Log(0) is undefined.
            Does not directly use any hardware intrinsics, nor does it incur branching.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.Internal.BitHelper.ToIntArrayLength(System.Int32)">
            <summary>How many ints must be allocated to represent n bits. Returns (n+31)/32, but avoids overflow.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.Internal.HashHelpers.GetFastModMultiplier(System.UInt32)">
            <summary>Returns approximate reciprocal of the divisor: ceil(2**64 / divisor).</summary>
            <remarks>This should only be used on 64-bit.</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.Internal.HashHelpers.FastMod(System.UInt32,System.UInt32,System.UInt64)">
            <summary>Performs a mod operation using the multiplier pre-computed with <see cref="M:Microsoft.CodeAnalysis.Collections.Internal.HashHelpers.GetFastModMultiplier(System.UInt32)"/>.</summary>
            <remarks>
            PERF: This improves performance in 64-bit scenarios at the expense of performance in 32-bit scenarios. Since
            we only build a single AnyCPU binary, we opt for improved performance in the 64-bit scenario.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Collections.Internal.ICollectionCalls">
            <summary>
            Provides static methods to invoke <see cref="T:System.Collections.ICollection"/> members on value types that explicitly implement the
            member.
            </summary>
            <remarks>
            Normally, invocation of explicit interface members requires boxing or copying the value type, which is
            especially problematic for operations that mutate the value. Invocation through these helpers behaves like a
            normal call to an implicitly implemented member.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Collections.Internal.ICollectionCalls`1">
            <summary>
            Provides static methods to invoke <see cref="T:System.Collections.Generic.ICollection`1"/> members on value types that explicitly implement
            the member.
            </summary>
            <remarks>
            Normally, invocation of explicit interface members requires boxing or copying the value type, which is
            especially problematic for operations that mutate the value. Invocation through these helpers behaves like a
            normal call to an implicitly implemented member.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Collections.Internal.IDictionaryCalls">
            <summary>
            Provides static methods to invoke <see cref="T:System.Collections.IDictionary"/> members on value types that explicitly implement the
            member.
            </summary>
            <remarks>
            Normally, invocation of explicit interface members requires boxing or copying the value type, which is
            especially problematic for operations that mutate the value. Invocation through these helpers behaves like a
            normal call to an implicitly implemented member.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Collections.Internal.IEnumerableCalls">
            <summary>
            Provides static methods to invoke <see cref="T:System.Collections.IEnumerable"/> members on value types that explicitly implement the
            member.
            </summary>
            <remarks>
            Normally, invocation of explicit interface members requires boxing or copying the value type, which is
            especially problematic for operations that mutate the value. Invocation through these helpers behaves like a
            normal call to an implicitly implemented member.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Collections.Internal.IEnumerableCalls`1">
            <summary>
            Provides static methods to invoke <see cref="T:System.Collections.Generic.IEnumerable`1"/> members on value types that explicitly implement
            the member.
            </summary>
            <remarks>
            Normally, invocation of explicit interface members requires boxing or copying the value type, which is
            especially problematic for operations that mutate the value. Invocation through these helpers behaves like a
            normal call to an implicitly implemented member.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Collections.Internal.IListCalls">
            <summary>
            Provides static methods to invoke <see cref="T:System.Collections.IList"/> members on value types that explicitly implement the
            member.
            </summary>
            <remarks>
            Normally, invocation of explicit interface members requires boxing or copying the value type, which is
            especially problematic for operations that mutate the value. Invocation through these helpers behaves like a
            normal call to an implicitly implemented member.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Collections.Internal.InsertionBehavior">
            <summary>
            Used internally to control behavior of insertion into a <see cref="T:System.Collections.Generic.Dictionary`2"/> or <see cref="T:System.Collections.Generic.HashSet`1"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Collections.Internal.InsertionBehavior.None">
            <summary>
            The default insertion behavior.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Collections.Internal.InsertionBehavior.OverwriteExisting">
            <summary>
            Specifies that an existing entry with the same key should be overwritten if encountered.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Collections.Internal.InsertionBehavior.ThrowOnExisting">
            <summary>
            Specifies that if an existing entry with the same key is encountered, an exception should be thrown.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.Internal.RoslynUnsafe.NullRef``1">
            <summary>
            Returns a by-ref to type <typeparamref name="T"/> that is a null reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.Internal.RoslynUnsafe.IsNullRef``1(``0@)">
            <summary>
            Returns if a given by-ref to type <typeparamref name="T"/> is a null reference.
            </summary>
            <remarks>
            This check is conceptually similar to <c>(void*)(&amp;source) == nullptr</c>.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.Internal.SegmentedArrayHelper.CalculateSegmentSize(System.Int32)">
            <summary>
            Calculates the maximum number of elements of size <paramref name="elementSize"/> which can fit into an array
            which has the following characteristics:
            <list type="bullet">
            <item><description>The array can be allocated in the small object heap.</description></item>
            <item><description>The array length is a power of 2.</description></item>
            </list>
            </summary>
            <param name="elementSize">The size of the elements in the array.</param>
            <returns>The segment size to use for small object heap segmented arrays.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.Internal.SegmentedArrayHelper.CalculateSegmentShift(System.Int32)">
            <summary>
            Calculates a shift which can be applied to an absolute index to get the page index within a segmented array.
            </summary>
            <param name="segmentSize">The number of elements in each page of the segmented array. Must be a power of 2.</param>
            <returns>The shift to apply to the absolute index to get the page index within a segmented array.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.Internal.SegmentedArrayHelper.CalculateOffsetMask(System.Int32)">
            <summary>
            Calculates a mask, which can be applied to an absolute index to get the index within a page of a segmented
            array.
            </summary>
            <param name="segmentSize">The number of elements in each page of the segmented array. Must be a power of 2.</param>
            <returns>The bit mask to obtain the index within a page from an absolute index within a segmented array.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Collections.Internal.SegmentedHashSetEqualityComparer`1">
            <summary>Equality comparer for hashsets of hashsets</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.Arg_ArrayPlusOffTooSmall">
            <summary>Destination array is not long enough to copy all the items in the collection. Check array index and length.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.Arg_HTCapacityOverflow">
            <summary>Hashtable's capacity overflowed and went negative. Check load factor, capacity and the current size of the table.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.Arg_KeyNotFoundWithKey">
            <summary>The given key '{0}' was not present in the dictionary.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.Arg_LongerThanDestArray">
            <summary>Destination array was not long enough. Check the destination index, length, and the array's lower bounds.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.Arg_LongerThanSrcArray">
            <summary>Source array was not long enough. Check the source index, length, and the array's lower bounds.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.Arg_NonZeroLowerBound">
            <summary>The lower bound of target array must be zero.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.Arg_RankMultiDimNotSupported">
            <summary>Only single dimensional arrays are supported for the requested action.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.Arg_WrongType">
            <summary>The value "{0}" is not of type "{1}" and cannot be used in this generic collection.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.Argument_AddingDuplicateWithKey">
            <summary>An item with the same key has already been added. Key: {0}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.Argument_IncompatibleArrayType">
            <summary>Target array type is not compatible with the type of items in the collection.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.Argument_InvalidOffLen">
            <summary>Offset and length were out of bounds for the array or count is greater than the number of elements from index to the end of the source collection.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.ArgumentOutOfRange_ArrayLB">
            <summary>Number was less than the array's lower bound in the first dimension.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.ArgumentOutOfRange_BiggerThanCollection">
            <summary>Larger than collection size.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.ArgumentOutOfRange_Count">
            <summary>Count must be positive and count must refer to a location within the string/array/collection.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.ArgumentOutOfRange_IndexMustBeLess">
            <summary>Index was out of range. Must be non-negative and less than the size of the collection.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.ArgumentOutOfRange_ListInsert">
            <summary>Index must be within the bounds of the List.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.ArgumentOutOfRange_NeedNonNegNum">
            <summary>Non-negative number required.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.ArgumentOutOfRange_SmallCapacity">
            <summary>capacity was less than the current size.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.InvalidOperation_ConcurrentOperationsNotSupported">
            <summary>Operations that change non-concurrent collections must have exclusive access. A concurrent update was performed on this collection and corrupted its state. The collection's state is no longer correct.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.InvalidOperation_EnumFailedVersion">
            <summary>Collection was modified; enumeration operation may not execute.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.InvalidOperation_EnumOpCantHappen">
            <summary>Enumeration has either not started or has already finished.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.InvalidOperation_IComparerFailed">
            <summary>Failed to compare two elements in the array.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.NotSupported_KeyCollectionSet">
            <summary>Mutating a key collection derived from a dictionary is not allowed.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.NotSupported_ValueCollectionSet">
            <summary>Mutating a value collection derived from a dictionary is not allowed.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.Rank_MustMatch">
            <summary>The specified arrays must have the same number of dimensions.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.NotSupported_FixedSizeCollection">
            <summary>Collection was of a fixed size.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.ArgumentException_OtherNotArrayOfCorrectLength">
            <summary>Object is not a array with the same number of elements as the array to compare it to.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.Arg_BogusIComparer">
            <summary>Unable to sort because the IComparer.Compare() method returns inconsistent results. Either a value does not compare equal to itself, or one value repeatedly compared to another value yields different results. IComparer: '{0}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.CannotFindOldValue">
            <summary>Cannot find the old value</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.ArgumentOutOfRange_IndexMustBeLessOrEqual">
            <summary>Index was out of range. Must be non-negative and less than or equal to the size of the collection.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked.Update``1(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList{``0}@,System.Func{Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList{``0},Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList{``0}})">
            <summary>
            Mutates a value in-place with optimistic locking transaction semantics via a specified transformation
            function. The transformation is retried as many times as necessary to win the optimistic locking race.
            </summary>
            <typeparam name="T">The type of value stored by the list.</typeparam>
            <param name="location">
            The variable or field to be changed, which may be accessed by multiple threads.
            </param>
            <param name="transformer">
            A function that mutates the value. This function should be side-effect free,
            as it may run multiple times when races occur with other threads.</param>
            <returns>
            <see langword="true"/> if the location's value is changed by applying the result of the
            <paramref name="transformer"/> function; otherwise, <see langword="false"/> if the location's value remained
            the same because the last invocation of <paramref name="transformer"/> returned the existing value.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked.Update``2(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList{``0}@,System.Func{Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList{``0},``1,Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList{``0}},``1)">
            <summary>
            Mutates a value in-place with optimistic locking transaction semantics via a specified transformation
            function. The transformation is retried as many times as necessary to win the optimistic locking race.
            </summary>
            <typeparam name="T">The type of value stored by the list.</typeparam>
            <typeparam name="TArg">The type of argument passed to the <paramref name="transformer"/>.</typeparam>
            <param name="location">
            The variable or field to be changed, which may be accessed by multiple threads.
            </param>
            <param name="transformer">
            A function that mutates the value. This function should be side-effect free, as it may run multiple times
            when races occur with other threads.</param>
            <param name="transformerArgument">The argument to pass to <paramref name="transformer"/>.</param>
            <returns>
            <see langword="true"/> if the location's value is changed by applying the result of the
            <paramref name="transformer"/> function; otherwise, <see langword="false"/> if the location's value remained
            the same because the last invocation of <paramref name="transformer"/> returned the existing value.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked.InterlockedExchange``1(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList{``0}@,Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList{``0})">
            <summary>
            Assigns a field or variable containing an immutable list to the specified value and returns the previous
            value.
            </summary>
            <typeparam name="T">The type of value stored by the list.</typeparam>
            <param name="location">The field or local variable to change.</param>
            <param name="value">The new value to assign.</param>
            <returns>The prior value at the specified <paramref name="location"/>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked.InterlockedCompareExchange``1(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList{``0}@,Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList{``0},Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList{``0})">
            <summary>
            Assigns a field or variable containing an immutable list to the specified value if it is currently equal to
            another specified value. Returns the previous value.
            </summary>
            <typeparam name="T">The type of value stored by the list.</typeparam>
            <param name="location">The field or local variable to change.</param>
            <param name="value">The new value to assign.</param>
            <param name="comparand">The value to check equality for before assigning.</param>
            <returns>The prior value at the specified <paramref name="location"/>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked.InterlockedInitialize``1(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList{``0}@,Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList{``0})">
            <summary>
            Assigns a field or variable containing an immutable list to the specified value if it is has not yet been
            initialized.
            </summary>
            <typeparam name="T">The type of value stored by the list.</typeparam>
            <param name="location">The field or local variable to change.</param>
            <param name="value">The new value to assign.</param>
            <returns><see langword="true"/> if the field was assigned the specified value; otherwise,
            <see langword="false"/> if it was previously initialized.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked.Update``1(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet{``0}@,System.Func{Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet{``0},Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet{``0}})">
            <summary>
            Mutates a value in-place with optimistic locking transaction semantics via a specified transformation
            function. The transformation is retried as many times as necessary to win the optimistic locking race.
            </summary>
            <typeparam name="T">The type of value stored by the set.</typeparam>
            <param name="location">
            The variable or field to be changed, which may be accessed by multiple threads.
            </param>
            <param name="transformer">
            A function that mutates the value. This function should be side-effect free,
            as it may run multiple times when races occur with other threads.</param>
            <returns>
            <see langword="true"/> if the location's value is changed by applying the result of the
            <paramref name="transformer"/> function; otherwise, <see langword="false"/> if the location's value remained
            the same because the last invocation of <paramref name="transformer"/> returned the existing value.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked.Update``2(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet{``0}@,System.Func{Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet{``0},``1,Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet{``0}},``1)">
            <summary>
            Mutates a value in-place with optimistic locking transaction semantics via a specified transformation
            function. The transformation is retried as many times as necessary to win the optimistic locking race.
            </summary>
            <typeparam name="T">The type of value stored by the set.</typeparam>
            <typeparam name="TArg">The type of argument passed to the <paramref name="transformer"/>.</typeparam>
            <param name="location">
            The variable or field to be changed, which may be accessed by multiple threads.
            </param>
            <param name="transformer">
            A function that mutates the value. This function should be side-effect free, as it may run multiple times
            when races occur with other threads.</param>
            <param name="transformerArgument">The argument to pass to <paramref name="transformer"/>.</param>
            <returns>
            <see langword="true"/> if the location's value is changed by applying the result of the
            <paramref name="transformer"/> function; otherwise, <see langword="false"/> if the location's value remained
            the same because the last invocation of <paramref name="transformer"/> returned the existing value.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked.InterlockedExchange``1(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet{``0}@,Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet{``0})">
            <summary>
            Assigns a field or variable containing an immutable set to the specified value and returns the
            previous value.
            </summary>
            <typeparam name="T">The type of value stored by the set.</typeparam>
            <param name="location">The field or local variable to change.</param>
            <param name="value">The new value to assign.</param>
            <returns>The prior value at the specified <paramref name="location"/>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked.InterlockedCompareExchange``1(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet{``0}@,Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet{``0},Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet{``0})">
            <summary>
            Assigns a field or variable containing an immutable set to the specified value if it is currently
            equal to another specified value. Returns the previous value.
            </summary>
            <typeparam name="T">The type of value stored by the set.</typeparam>
            <param name="location">The field or local variable to change.</param>
            <param name="value">The new value to assign.</param>
            <param name="comparand">The value to check equality for before assigning.</param>
            <returns>The prior value at the specified <paramref name="location"/>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked.InterlockedInitialize``1(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet{``0}@,Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet{``0})">
            <summary>
            Assigns a field or variable containing an immutable set to the specified value if it is has not yet
            been initialized.
            </summary>
            <typeparam name="T">The type of value stored by the set.</typeparam>
            <param name="location">The field or local variable to change.</param>
            <param name="value">The new value to assign.</param>
            <returns><see langword="true"/> if the field was assigned the specified value; otherwise,
            <see langword="false"/> if it was previously initialized.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked.Update``2(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1}@,System.Func{Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1},Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1}})">
            <summary>
            Mutates a value in-place with optimistic locking transaction semantics via a specified transformation
            function. The transformation is retried as many times as necessary to win the optimistic locking race.
            </summary>
            <typeparam name="TKey">The type of key stored by the dictionary.</typeparam>
            <typeparam name="TValue">The type of value stored by the dictionary.</typeparam>
            <param name="location">
            The variable or field to be changed, which may be accessed by multiple threads.
            </param>
            <param name="transformer">
            A function that mutates the value. This function should be side-effect free,
            as it may run multiple times when races occur with other threads.</param>
            <returns>
            <see langword="true"/> if the location's value is changed by applying the result of the
            <paramref name="transformer"/> function; otherwise, <see langword="false"/> if the location's value remained
            the same because the last invocation of <paramref name="transformer"/> returned the existing value.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked.Update``3(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1}@,System.Func{Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1},``2,Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1}},``2)">
            <summary>
            Mutates a value in-place with optimistic locking transaction semantics via a specified transformation
            function. The transformation is retried as many times as necessary to win the optimistic locking race.
            </summary>
            <typeparam name="TKey">The type of key stored by the dictionary.</typeparam>
            <typeparam name="TValue">The type of value stored by the dictionary.</typeparam>
            <typeparam name="TArg">The type of argument passed to the <paramref name="transformer"/>.</typeparam>
            <param name="location">
            The variable or field to be changed, which may be accessed by multiple threads.
            </param>
            <param name="transformer">
            A function that mutates the value. This function should be side-effect free, as it may run multiple times
            when races occur with other threads.</param>
            <param name="transformerArgument">The argument to pass to <paramref name="transformer"/>.</param>
            <returns>
            <see langword="true"/> if the location's value is changed by applying the result of the
            <paramref name="transformer"/> function; otherwise, <see langword="false"/> if the location's value remained
            the same because the last invocation of <paramref name="transformer"/> returned the existing value.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked.InterlockedExchange``2(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1}@,Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1})">
            <summary>
            Assigns a field or variable containing an immutable dictionary to the specified value and returns the
            previous value.
            </summary>
            <typeparam name="TKey">The type of key stored by the dictionary.</typeparam>
            <typeparam name="TValue">The type of value stored by the dictionary.</typeparam>
            <param name="location">The field or local variable to change.</param>
            <param name="value">The new value to assign.</param>
            <returns>The prior value at the specified <paramref name="location"/>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked.InterlockedCompareExchange``2(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1}@,Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1},Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1})">
            <summary>
            Assigns a field or variable containing an immutable dictionary to the specified value if it is currently
            equal to another specified value. Returns the previous value.
            </summary>
            <typeparam name="TKey">The type of key stored by the dictionary.</typeparam>
            <typeparam name="TValue">The type of value stored by the dictionary.</typeparam>
            <param name="location">The field or local variable to change.</param>
            <param name="value">The new value to assign.</param>
            <param name="comparand">The value to check equality for before assigning.</param>
            <returns>The prior value at the specified <paramref name="location"/>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked.InterlockedInitialize``2(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1}@,Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1})">
            <summary>
            Assigns a field or variable containing an immutable dictionary to the specified value if it is has not yet
            been initialized.
            </summary>
            <typeparam name="TKey">The type of key stored by the dictionary.</typeparam>
            <typeparam name="TValue">The type of value stored by the dictionary.</typeparam>
            <param name="location">The field or local variable to change.</param>
            <param name="value">The new value to assign.</param>
            <returns><see langword="true"/> if the field was assigned the specified value; otherwise,
            <see langword="false"/> if it was previously initialized.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked.GetOrAdd``3(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1}@,``0,System.Func{``0,``2,``1},``2)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableInterlocked.GetOrAdd``3(System.Collections.Immutable.ImmutableDictionary{``0,``1}@,``0,System.Func{``0,``2,``1},``2)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked.GetOrAdd``2(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1}@,``0,System.Func{``0,``1})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableInterlocked.GetOrAdd``2(System.Collections.Immutable.ImmutableDictionary{``0,``1}@,``0,System.Func{``0,``1})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked.GetOrAdd``2(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1}@,``0,``1)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableInterlocked.GetOrAdd``2(System.Collections.Immutable.ImmutableDictionary{``0,``1}@,``0,``1)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked.AddOrUpdate``2(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1}@,``0,System.Func{``0,``1},System.Func{``0,``1,``1})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableInterlocked.AddOrUpdate``2(System.Collections.Immutable.ImmutableDictionary{``0,``1}@,``0,System.Func{``0,``1},System.Func{``0,``1,``1})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked.AddOrUpdate``2(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1}@,``0,``1,System.Func{``0,``1,``1})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableInterlocked.AddOrUpdate``2(System.Collections.Immutable.ImmutableDictionary{``0,``1}@,``0,``1,System.Func{``0,``1,``1})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked.TryAdd``2(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1}@,``0,``1)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableInterlocked.TryAdd``2(System.Collections.Immutable.ImmutableDictionary{``0,``1}@,``0,``1)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked.TryUpdate``2(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1}@,``0,``1,``1)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableInterlocked.TryUpdate``2(System.Collections.Immutable.ImmutableDictionary{``0,``1}@,``0,``1,``1)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked.TryRemove``2(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1}@,``0,``1@)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableInterlocked.TryRemove``2(System.Collections.Immutable.ImmutableDictionary{``0,``1}@,``0,``1@)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked.VolatileRead``1(System.Collections.Immutable.ImmutableArray{``0}@)">
            <summary>
            Reads from an ImmutableArray location, ensuring that a read barrier is inserted to prevent any subsequent reads from being reordered before this read.
            </summary>
            <remarks>
            This method is not intended to be used to provide write barriers.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked.VolatileWrite``1(System.Collections.Immutable.ImmutableArray{``0}@,System.Collections.Immutable.ImmutableArray{``0})">
            <summary>
            Writes to an ImmutableArray location, ensuring that a write barrier is inserted to prevent any prior writes from being reordered after this write.
            </summary>
            <remarks>
            This method is not intended to be used to provide read barriers.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedArray.Clear``1(Microsoft.CodeAnalysis.Collections.SegmentedArray{``0},System.Int32,System.Int32)">
            <seealso cref="M:System.Array.Clear(System.Array,System.Int32,System.Int32)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedArray.Copy``1(Microsoft.CodeAnalysis.Collections.SegmentedArray{``0},Microsoft.CodeAnalysis.Collections.SegmentedArray{``0},System.Int32)">
            <seealso cref="M:System.Array.Copy(System.Array,System.Array,System.Int32)"/>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Collections.SegmentedArray`1">
            <summary>
            Defines a fixed-size collection with the same API surface and behavior as an "SZArray", which is a
            single-dimensional zero-based array commonly represented in C# as <c>T[]</c>. The implementation of this
            collection uses segmented arrays to avoid placing objects on the Large Object Heap.
            </summary>
            <typeparam name="T">The type of elements stored in the array.</typeparam>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Collections.SegmentedArray`1.PrivateMarshal">
            <summary>
            Private helper class for use only by <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedCollectionsMarshal"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedArray`1.PrivateMarshal.AsSegments(Microsoft.CodeAnalysis.Collections.SegmentedArray{`0})">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.Collections.SegmentedCollectionsMarshal.AsSegments``1(Microsoft.CodeAnalysis.Collections.SegmentedArray{``0})"/>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.SegmentedArray`1.SegmentSize">
             <summary>
             The number of elements in each page of the segmented array of type <typeparamref name="T"/>.
             </summary>
             <remarks>
             <para>The segment size is calculated according to <see cref="M:System.Runtime.CompilerServices.Unsafe.SizeOf``1"/>, performs the IL operation
             defined by <see cref="F:System.Reflection.Emit.OpCodes.Sizeof"/>. ECMA-335 defines this operation with the following note:</para>
            
             <para><c>sizeof</c> returns the total size that would be occupied by each element in an array of this type 
             including any padding the implementation chooses to add. Specifically, array elements lie <c>sizeof</c>
             bytes apart.</para>
             </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.SegmentedArray`1.SegmentShift">
            <summary>
            The bit shift to apply to an array index to get the page index within <see cref="F:Microsoft.CodeAnalysis.Collections.SegmentedArray`1._items"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.SegmentedArray`1.OffsetMask">
            <summary>
            The bit mask to apply to an array index to get the index within a page of <see cref="F:Microsoft.CodeAnalysis.Collections.SegmentedArray`1._items"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Collections.SegmentedCollectionsMarshal">
            <summary>
            An unsafe class that provides a set of methods to access the underlying data representations of immutable segmented
            collections.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedCollectionsMarshal.AsSegments``1(Microsoft.CodeAnalysis.Collections.SegmentedArray{``0})">
            <summary>
            Gets the backing storage array for a <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedArray`1"/>.
            </summary>
            <typeparam name="T">The type of elements stored in the array.</typeparam>
            <param name="array">The segmented array.</param>
            <returns>The backing storage array for the segmented array. Note that replacing segments within the returned
            value will invalidate the <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedArray`1"/> data structure.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedCollectionsMarshal.AsSegmentedArray``1(System.Int32,``0[][])">
            <summary>
            Gets a <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedArray`1"/> value wrapping the input T[][].
            </summary>
            <typeparam name="T">The type of elements in the input.</typeparam>
            <param name="length">The combined length of the input arrays</param>
            <param name="segments">The input array to wrap in the returned <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedArray`1"/> value.</param>
            <returns>A <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedArray`1"/> value wrapping <paramref name="segments"/>.</returns>
            <remarks>
            <para>
            When using this method, callers should take extra care to ensure that they're the sole owners of the input
            array, and that it won't be modified once the returned <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedArray`1"/> value starts
            being used. Doing so might cause undefined behavior in code paths which don't expect the contents of a given
            <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedArray`1"/> values to change outside their control.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="segments"/> is <see langword="null"/></exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedCollectionsMarshal.GetValueRefOrNullRef``2(Microsoft.CodeAnalysis.Collections.SegmentedDictionary{``0,``1},``0)">
            <summary>
            Gets either a ref to a <typeparamref name="TValue"/> in the <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedDictionary`2"/> or a
            ref null if it does not exist in the <paramref name="dictionary"/>.
            </summary>
            <param name="dictionary">The dictionary to get the ref to <typeparamref name="TValue"/> from.</param>
            <param name="key">The key used for lookup.</param>
            <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
            <typeparam name="TValue">The type of the values in the dictionary.</typeparam>
            <remarks>
            Items should not be added or removed from the <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedDictionary`2"/> while the ref
            <typeparamref name="TValue"/> is in use. The ref null can be detected using <see cref="M:System.Runtime.CompilerServices.Unsafe.IsNullRef``1(``0@)"/>.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedCollectionsMarshal.GetValueRefOrNullRef``2(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1},``0)">
            <summary>
            Gets either a read-only ref to a <typeparamref name="TValue"/> in the <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2"/>
            or a ref null if it does not exist in the <paramref name="dictionary"/>.
            </summary>
            <param name="dictionary">The dictionary to get the ref to <typeparamref name="TValue"/> from.</param>
            <param name="key">The key used for lookup.</param>
            <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
            <typeparam name="TValue">The type of the values in the dictionary.</typeparam>
            <remarks>
            The ref null can be detected using <see cref="M:System.Runtime.CompilerServices.Unsafe.IsNullRef``1(``0@)"/>.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedCollectionsMarshal.GetValueRefOrNullRef``2(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1}.Builder,``0)">
            <summary>
            Gets either a ref to a <typeparamref name="TValue"/> in the <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2.Builder"/>
            or a ref null if it does not exist in the <paramref name="dictionary"/>.
            </summary>
            <param name="dictionary">The dictionary to get the ref to <typeparamref name="TValue"/> from.</param>
            <param name="key">The key used for lookup.</param>
            <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
            <typeparam name="TValue">The type of the values in the dictionary.</typeparam>
            <remarks>
            Items should not be added or removed from the <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2.Builder"/>
            while the ref <typeparamref name="TValue"/> is in use. The ref null can be detected using
            <see cref="M:System.Runtime.CompilerServices.Unsafe.IsNullRef``1(``0@)"/>.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedCollectionsMarshal.AsImmutableSegmentedList``1(Microsoft.CodeAnalysis.Collections.SegmentedList{``0})">
            <summary>
            Gets an <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1"/> value wrapping the input <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedList`1"/>.
            </summary>
            <typeparam name="T">The type of elements in the input segmented list.</typeparam>
            <param name="list">The input segmented list to wrap in the returned <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1"/> value.</param>
            <returns>An <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1"/> value wrapping <paramref name="list"/>.</returns>
            <remarks>
            <para>
            When using this method, callers should take extra care to ensure that they're the sole owners of the input
            list, and that it won't be modified once the returned <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1"/> value starts
            being used. Doing so might cause undefined behavior in code paths which don't expect the contents of a given
            <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1"/> values to change after its creation.
            </para>
            <para>
            If <paramref name="list"/> is <see langword="null"/>, the returned <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1"/> value
            will be uninitialized (i.e. its <see cref="P:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.IsDefault"/> property will be
            <see langword="true"/>).
            </para>
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedCollectionsMarshal.AsSegmentedList``1(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList{``0})">
            <summary>
            Gets the underlying <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedList`1"/> for an input <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1"/> value.
            </summary>
            <typeparam name="T">The type of elements in the input <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1"/> value.</typeparam>
            <param name="list">The input <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1"/> value to get the underlying <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedList`1"/> from.</param>
            <returns>The underlying <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedList`1"/> for <paramref name="list"/>, if present; otherwise, <see langword="null"/>.</returns>
            <remarks>
            <para>
            When using this method, callers should make sure to not pass the resulting underlying list to methods that
            might mutate it. Doing so might cause undefined behavior in code paths using <paramref name="list"/> which
            don't expect the contents of the <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1"/> value to change.
            </para>
            <para>
            If <paramref name="list"/> is uninitialized (i.e. its <see cref="P:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.IsDefault"/> property is
            <see langword="true"/>), the resulting <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedList`1"/> will be <see langword="null"/>.
            </para>
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedCollectionsMarshal.AsImmutableSegmentedHashSet``1(Microsoft.CodeAnalysis.Collections.SegmentedHashSet{``0})">
            <summary>
            Gets an <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1"/> value wrapping the input <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/>.
            </summary>
            <typeparam name="T">The type of elements in the input segmented hash set.</typeparam>
            <param name="set">The input segmented hash set to wrap in the returned <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1"/> value.</param>
            <returns>An <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1"/> value wrapping <paramref name="set"/>.</returns>
            <remarks>
            <para>
            When using this method, callers should take extra care to ensure that they're the sole owners of the input
            set, and that it won't be modified once the returned <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1"/> value starts
            being used. Doing so might cause undefined behavior in code paths which don't expect the contents of a given
            <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1"/> values to change after its creation.
            </para>
            <para>
            If <paramref name="set"/> is <see langword="null"/>, the returned <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1"/>
            value will be uninitialized (i.e. its <see cref="P:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.IsDefault"/> property will be
            <see langword="true"/>).
            </para>
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedCollectionsMarshal.AsSegmentedHashSet``1(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet{``0})">
            <summary>
            Gets the underlying <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> for an input <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1"/> value.
            </summary>
            <typeparam name="T">The type of elements in the input <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1"/> value.</typeparam>
            <param name="set">The input <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1"/> value to get the underlying <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> from.</param>
            <returns>The underlying <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> for <paramref name="set"/>, if present; otherwise, <see langword="null"/>.</returns>
            <remarks>
            <para>
            When using this method, callers should make sure to not pass the resulting underlying hash set to methods that
            might mutate it. Doing so might cause undefined behavior in code paths using <paramref name="set"/> which
            don't expect the contents of the <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1"/> value to change.
            </para>
            <para>
            If <paramref name="set"/> is uninitialized (i.e. its <see cref="P:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.IsDefault"/>
            property is <see langword="true"/>), the resulting <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> will be <see langword="null"/>.
            </para>
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedCollectionsMarshal.AsImmutableSegmentedDictionary``2(Microsoft.CodeAnalysis.Collections.SegmentedDictionary{``0,``1})">
            <summary>
            Gets an <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2"/> value wrapping the input <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedDictionary`2"/>.
            </summary>
            <typeparam name="TKey">The type of keys in the input segmented dictionary.</typeparam>
            <typeparam name="TValue">The type of values in the input segmented dictionary.</typeparam>
            <param name="dictionary">The input segmented dictionary to wrap in the returned <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2"/> value.</param>
            <returns>An <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2"/> value wrapping <paramref name="dictionary"/>.</returns>
            <remarks>
            <para>
            When using this method, callers should take extra care to ensure that they're the sole owners of the input
            dictionary, and that it won't be modified once the returned <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2"/>
            value starts being used. Doing so might cause undefined behavior in code paths which don't expect the contents
            of a given <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2"/> values to change after its creation.
            </para>
            <para>
            If <paramref name="dictionary"/> is <see langword="null"/>, the returned <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2"/>
            value will be uninitialized (i.e. its <see cref="P:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2.IsDefault"/>
            property will be <see langword="true"/>).
            </para>
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedCollectionsMarshal.AsSegmentedDictionary``2(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1})">
            <summary>
            Gets the underlying <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedDictionary`2"/> for an input <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2"/> value.
            </summary>
            <typeparam name="TKey">The type of keys in the input <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2"/> value.</typeparam>
            <typeparam name="TValue">The type of values in the input <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2"/> value.</typeparam>
            <param name="dictionary">The input <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2"/> value to get the underlying <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedDictionary`2"/> from.</param>
            <returns>The underlying <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedDictionary`2"/> for <paramref name="dictionary"/>, if present; otherwise, <see langword="null"/>.</returns>
            <remarks>
            <para>
            When using this method, callers should make sure to not pass the resulting underlying dictionary to methods that
            might mutate it. Doing so might cause undefined behavior in code paths using <paramref name="dictionary"/> which
            don't expect the contents of the <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2"/> value to change.
            </para>
            <para>
            If <paramref name="dictionary"/> is uninitialized (i.e. its <see cref="P:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2.IsDefault"/>
            property is <see langword="true"/>), the resulting <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedDictionary`2"/> will be <see langword="null"/>.
            </para>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Collections.SegmentedDictionary`2">
            <summary>
            Represents a collection of keys and values.
            </summary>
            <remarks>
            <para>This collection has the same performance characteristics as <see cref="T:System.Collections.Generic.Dictionary`2"/>, but
            uses segmented arrays to avoid allocations in the Large Object Heap.</para>
            </remarks>
            <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
            <typeparam name="TValue">The type of the values in the dictionary.</typeparam>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Collections.SegmentedDictionary`2.PrivateMarshal">
            <summary>
            Private helper class for use only by <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedCollectionsMarshal"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedDictionary`2.PrivateMarshal.FindValue(Microsoft.CodeAnalysis.Collections.SegmentedDictionary{`0,`1},`0)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.Collections.SegmentedCollectionsMarshal.GetValueRefOrNullRef``2(Microsoft.CodeAnalysis.Collections.SegmentedDictionary{``0,``1},``0)"/>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Collections.SegmentedDictionary`2._comparer">
            <summary>
            <see cref="P:System.Collections.Generic.EqualityComparer`1.Default"/> doesn't devirtualize on .NET Framework, so we always ensure
            <see cref="F:Microsoft.CodeAnalysis.Collections.SegmentedDictionary`2._comparer"/> is initialized to a non-<see langword="null"/> value.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedDictionary`2.EnsureCapacity(System.Int32)">
            <summary>
            Ensures that the dictionary can hold up to 'capacity' entries without any further expansion of its backing storage
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedDictionary`2.TrimExcess">
             <summary>
             Sets the capacity of this dictionary to what it would be if it had been originally initialized with all its entries
             </summary>
             <remarks>
             This method can be used to minimize the memory overhead
             once it is known that no new elements will be added.
            
             To allocate minimum size storage array, execute the following statements:
            
             dictionary.Clear();
             dictionary.TrimExcess();
             </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedDictionary`2.TrimExcess(System.Int32)">
            <summary>
            Sets the capacity of this dictionary to hold up 'capacity' entries without any further expansion of its backing storage
            </summary>
            <remarks>
            This method can be used to minimize the memory overhead
            once it is known that no new elements will be added.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Collections.SegmentedDictionary`2.Entry._next">
            <summary>
            0-based index of next entry in chain: -1 means end of chain
            also encodes whether this entry _itself_ is part of the free list by changing sign and subtracting 3,
            so -2 means end of free list, -3 means index 0 but on free list, -4 means index 1 but on free list, etc.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.StackAllocThreshold">
            <summary>Cutoff point for stackallocs. This corresponds to the number of ints.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.ShrinkThreshold">
            <summary>
            When constructing a hashset from an existing collection, it may contain duplicates,
            so this is used as the max acceptable excess ratio of capacity to count. Note that
            this is only used on the ctor and not to automatically shrink if the hashset has, e.g,
            a lot of adds followed by removes. Users must explicitly shrink by calling TrimExcess.
            This is set to 3 because capacity is acceptable as 2x rounded up to nearest prime.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1._comparer">
            <summary>
            <see cref="P:System.Collections.Generic.EqualityComparer`1.Default"/> doesn't devirtualize on .NET Framework, so we always ensure
            <see cref="F:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1._comparer"/> is initialized to a non-<see langword="null"/> value.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.ConstructFrom(Microsoft.CodeAnalysis.Collections.SegmentedHashSet{`0})">
            <summary>Initializes the SegmentedHashSet from another SegmentedHashSet with the same element type and equality comparer.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.Clear">
            <summary>Removes all elements from the <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.Contains(`0)">
            <summary>Determines whether the <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> contains the specified element.</summary>
            <param name="item">The element to locate in the <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object.</param>
            <returns>true if the <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object contains the specified element; otherwise, false.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.FindItemIndex(`0)">
            <summary>Gets the index of the item in <see cref="F:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1._entries"/>, or -1 if it's not in the set.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.GetBucketRef(System.Int32)">
            <summary>Gets a reference to the specified hashcode's bucket, containing an index into <see cref="F:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1._entries"/>.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.Count">
            <summary>Gets the number of elements that are contained in the set.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.Add(`0)">
            <summary>Adds the specified element to the <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/>.</summary>
            <param name="item">The element to add to the set.</param>
            <returns>true if the element is added to the <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object; false if the element is already present.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.TryGetValue(`0,`0@)">
            <summary>Searches the set for a given value and returns the equal value it finds, if any.</summary>
            <param name="equalValue">The value to search for.</param>
            <param name="actualValue">The value from the set that the search found, or the default value of <typeparamref name="T"/> when the search yielded no match.</param>
            <returns>A value indicating whether the search was successful.</returns>
            <remarks>
            This can be useful when you want to reuse a previously stored reference instead of
            a newly constructed one (so that more sharing of references can occur) or to look up
            a value that has more complete data than the value you currently have, although their
            comparer functions indicate they are equal.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.UnionWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>Modifies the current <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object to contain all elements that are present in itself, the specified collection, or both.</summary>
            <param name="other">The collection to compare to the current <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.IntersectWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>Modifies the current <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object to contain only elements that are present in that object and in the specified collection.</summary>
            <param name="other">The collection to compare to the current <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.ExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>Removes all elements in the specified collection from the current <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object.</summary>
            <param name="other">The collection to compare to the current <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>Modifies the current <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object to contain only elements that are present either in that object or in the specified collection, but not both.</summary>
            <param name="other">The collection to compare to the current <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>Determines whether a <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object is a subset of the specified collection.</summary>
            <param name="other">The collection to compare to the current <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object.</param>
            <returns>true if the <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object is a subset of <paramref name="other"/>; otherwise, false.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>Determines whether a <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object is a proper subset of the specified collection.</summary>
            <param name="other">The collection to compare to the current <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object.</param>
            <returns>true if the <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object is a proper subset of <paramref name="other"/>; otherwise, false.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>Determines whether a <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object is a proper superset of the specified collection.</summary>
            <param name="other">The collection to compare to the current <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object.</param>
            <returns>true if the <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object is a superset of <paramref name="other"/>; otherwise, false.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>Determines whether a <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object is a proper superset of the specified collection.</summary>
            <param name="other">The collection to compare to the current <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object.</param>
            <returns>true if the <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object is a proper superset of <paramref name="other"/>; otherwise, false.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})">
            <summary>Determines whether the current <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object and a specified collection share common elements.</summary>
            <param name="other">The collection to compare to the current <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object.</param>
            <returns>true if the <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object and <paramref name="other"/> share at least one common element; otherwise, false.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})">
            <summary>Determines whether a <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object and the specified collection contain the same elements.</summary>
            <param name="other">The collection to compare to the current <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object.</param>
            <returns>true if the <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object is equal to <paramref name="other"/>; otherwise, false.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.CopyTo(`0[],System.Int32)">
            <summary>Copies the elements of a <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object to an array, starting at the specified array index.</summary>
            <param name="array">The destination array.</param>
            <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.RemoveWhere(System.Predicate{`0})">
            <summary>Removes all elements that match the conditions defined by the specified predicate from a <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> collection.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.Comparer">
            <summary>Gets the <see cref="T:System.Collections.IEqualityComparer"/> object that is used to determine equality for the values in the set.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.EnsureCapacity(System.Int32)">
            <summary>Ensures that this hash set can hold the specified number of elements without growing.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.TrimExcess">
            <summary>
            Sets the capacity of a <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object to the actual number of elements it contains,
            rounded up to a nearby, implementation-specific value.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.CreateSetComparer">
            <summary>Returns an <see cref="T:System.Collections.IEqualityComparer"/> object that can be used for equality testing of a <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.Initialize(System.Int32)">
            <summary>
            Initializes buckets and slots arrays. Uses suggested capacity by finding next prime
            greater than or equal to capacity.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.AddIfNotPresent(`0,System.Int32@)">
            <summary>Adds the specified element to the set if it's not already contained.</summary>
            <param name="value">The element to add to the set.</param>
            <param name="location">The index into <see cref="F:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1._entries"/> of the element.</param>
            <returns>true if the element is added to the <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object; false if the element is already present.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.IsSubsetOfHashSetWithSameComparer(Microsoft.CodeAnalysis.Collections.SegmentedHashSet{`0})">
             <summary>
             Implementation Notes:
             If other is a hashset and is using same equality comparer, then checking subset is
             faster. Simply check that each element in this is in other.
            
             Note: if other doesn't use same equality comparer, then Contains check is invalid,
             which is why callers must take are of this.
            
             If callers are concerned about whether this is a proper subset, they take care of that.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.IntersectWithHashSetWithSameComparer(Microsoft.CodeAnalysis.Collections.SegmentedHashSet{`0})">
            <summary>
            If other is a hashset that uses same equality comparer, intersect is much faster
            because we can use other's Contains
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.IntersectWithEnumerable(System.Collections.Generic.IEnumerable{`0})">
             <summary>
             Iterate over other. If contained in this, mark an element in bit array corresponding to
             its position in _slots. If anything is unmarked (in bit array), remove it.
            
             This attempts to allocate on the stack, if below StackAllocThreshold.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.SymmetricExceptWithUniqueHashSet(Microsoft.CodeAnalysis.Collections.SegmentedHashSet{`0})">
             <summary>
             if other is a set, we can assume it doesn't have duplicate elements, so use this
             technique: if can't remove, then it wasn't present in this set, so add.
            
             As with other methods, callers take care of ensuring that other is a hashset using the
             same equality comparer.
             </summary>
             <param name="other"></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.SymmetricExceptWithEnumerable(System.Collections.Generic.IEnumerable{`0})">
             <summary>
             Implementation notes:
            
             Used for symmetric except when other isn't a SegmentedHashSet. This is more tedious because
             other may contain duplicates. SegmentedHashSet technique could fail in these situations:
             1. Other has a duplicate that's not in this: SegmentedHashSet technique would add then
             remove it.
             2. Other has a duplicate that's in this: SegmentedHashSet technique would remove then add it
             back.
             In general, its presence would be toggled each time it appears in other.
            
             This technique uses bit marking to indicate whether to add/remove the item. If already
             present in collection, it will get marked for deletion. If added from other, it will
             get marked as something not to remove.
            
             </summary>
             <param name="other"></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.CheckUniqueAndUnfoundElements(System.Collections.Generic.IEnumerable{`0},System.Boolean)">
             <summary>
             Determines counts that can be used to determine equality, subset, and superset. This
             is only used when other is an IEnumerable and not a SegmentedHashSet. If other is a SegmentedHashSet
             these properties can be checked faster without use of marking because we can assume
             other has no duplicates.
            
             The following count checks are performed by callers:
             1. Equals: checks if unfoundCount = 0 and uniqueFoundCount = _count; i.e. everything
             in other is in this and everything in this is in other
             2. Subset: checks if unfoundCount >= 0 and uniqueFoundCount = _count; i.e. other may
             have elements not in this and everything in this is in other
             3. Proper subset: checks if unfoundCount > 0 and uniqueFoundCount = _count; i.e
             other must have at least one element not in this and everything in this is in other
             4. Proper superset: checks if unfound count = 0 and uniqueFoundCount strictly less
             than _count; i.e. everything in other was in this and this had at least one element
             not contained in other.
            
             An earlier implementation used delegates to perform these checks rather than returning
             an ElementCount struct; however this was changed due to the perf overhead of delegates.
             </summary>
             <param name="other"></param>
             <param name="returnIfUnfound">Allows us to finish faster for equals and proper superset
             because unfoundCount must be 0.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.EqualityComparersAreEqual(Microsoft.CodeAnalysis.Collections.SegmentedHashSet{`0},Microsoft.CodeAnalysis.Collections.SegmentedHashSet{`0})">
            <summary>
            Checks if equality comparers are equal. This is used for algorithms that can
            speed up if it knows the other item has unique elements. I.e. if they're using
            different equality comparers, then uniqueness assumption between sets break.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.Entry._next">
            <summary>
            0-based index of next entry in chain: -1 means end of chain
            also encodes whether this entry _itself_ is part of the free list by changing sign and subtracting 3,
            so -2 means end of free list, -3 means index 0 but on free list, -4 means index 1 but on free list, etc.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Collections.SegmentedList`1">
            <summary>
            Represents a strongly typed list of objects that can be accessed by index. Provides methods to search, sort, and
            manipulate lists.
            </summary>
            <remarks>
            <para>This collection has the same performance characteristics as <see cref="T:System.Collections.Generic.List`1"/>, but uses segmented
            arrays to avoid allocations in the Large Object Heap.</para>
            </remarks>
            <typeparam name="T">The type of elements in the list.</typeparam>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedList`1.EnsureCapacity(System.Int32)">
            <summary>
            Ensures that the capacity of this list is at least the specified <paramref name="capacity"/>.
            If the current capacity of the list is less than specified <paramref name="capacity"/>,
            the capacity is increased by continuously twice current capacity until it is at least the specified <paramref name="capacity"/>.
            </summary>
            <param name="capacity">The minimum capacity to ensure.</param>
            <returns>The new capacity of this list.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedList`1.Grow(System.Int32)">
            <summary>
            Increase the capacity of this list to at least the specified <paramref name="capacity"/>.
            </summary>
            <param name="capacity">The minimum capacity to ensure.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedList`1.Slice(System.Int32,System.Int32)">
            <summary>
            Creates a shallow copy of a range of elements in the source <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedList`1" />.
            </summary>
            <param name="start">The zero-based <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedList`1" /> index at which the range starts.</param>
            <param name="length">The length of the range.</param>
            <returns>A shallow copy of a range of elements in the source <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedList`1" />.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="start" /> is less than 0.
            -or-
            <paramref name="length" /> is less than 0.
            </exception>
            <exception cref="T:System.ArgumentException"><paramref name="start" /> and <paramref name="length" /> do not denote a valid range of elements in the <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedList`1" />.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Contract.ThrowIfNull``1(``0,System.Int32,System.String)">
            <summary>
            Throws a non-accessible exception if the provided value is null.  This method executes in
            all builds
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Contract.ThrowIfNull``1(System.Nullable{``0},System.Int32,System.String)">
            <summary>
            Throws a non-accessible exception if the provided value is null.  This method executes in
            all builds
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Contract.ThrowIfNull``1(``0,System.String,System.Int32,System.String)">
            <summary>
            Throws a non-accessible exception if the provided value is null.  This method executes in
            all builds
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Contract.ThrowIfNull``1(``0,Microsoft.CodeAnalysis.Contract.ThrowIfNullInterpolatedStringHandler{``0},System.Int32,System.String)">
            <summary>
            Throws a non-accessible exception if the provided value is null.  This method executes in
            all builds
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Contract.ThrowIfFalse(System.Boolean,System.Int32,System.String)">
            <summary>
            Throws a non-accessible exception if the provided value is false.  This method executes
            in all builds
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Contract.ThrowIfFalse(System.Boolean,System.String,System.Int32,System.String)">
            <summary>
            Throws a non-accessible exception if the provided value is false.  This method executes
            in all builds
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Contract.ThrowIfFalse(System.Boolean,Microsoft.CodeAnalysis.Contract.ThrowIfFalseInterpolatedStringHandler,System.Int32,System.String)">
            <summary>
            Throws a non-accessible exception if the provided value is false.  This method executes
            in all builds
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Contract.ThrowIfTrue(System.Boolean,System.Int32,System.String)">
            <summary>
            Throws a non-accessible exception if the provided value is true. This method executes in
            all builds.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Contract.ThrowIfTrue(System.Boolean,System.String,System.Int32,System.String)">
            <summary>
            Throws a non-accessible exception if the provided value is true. This method executes in
            all builds.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Contract.ThrowIfTrue(System.Boolean,Microsoft.CodeAnalysis.Contract.ThrowIfTrueInterpolatedStringHandler,System.Int32,System.String)">
            <summary>
            Throws a non-accessible exception if the provided value is true. This method executes in
            all builds.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ExceptionUtilities.UnexpectedValue(System.Object)">
            <summary>
            Creates an <see cref="T:System.InvalidOperationException"/> with information about an unexpected value.
            </summary>
            <param name="o">The unexpected value.</param>
            <returns>The <see cref="T:System.InvalidOperationException"/>, which should be thrown by the caller.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ExceptionUtilities.IsCurrentOperationBeingCancelled(System.Exception,System.Threading.CancellationToken)">
            <summary>
            Determine if an exception was an <see cref="T:System.OperationCanceledException"/>, and that the provided token caused the cancellation.
            </summary>
            <param name="exception">The exception to test.</param>
            <param name="cancellationToken">Checked to see if the provided token was cancelled.</param>
            <returns><see langword="true"/> if the exception was an <see cref="T:System.OperationCanceledException" /> and the token was canceled.</returns>
        </member>
        <member name="M:Roslyn.Utilities.TaskExtensions.VerifyCompleted(System.Threading.Tasks.Task)">
            <summary>
            Asserts the <see cref="T:System.Threading.Tasks.Task"/> passed has already been completed.
            </summary>
            <remarks>
            This is useful for a specific case: sometimes you might be calling an API that is "sometimes" async, and you're
            calling it from a synchronous method where you know it should have completed synchronously. This is an easy
            way to assert that while silencing any compiler complaints.
            </remarks>
        </member>
        <member name="M:Roslyn.Utilities.TaskExtensions.VerifyCompleted``1(System.Threading.Tasks.Task{``0})">
            <summary>
            Asserts the <see cref="T:System.Threading.Tasks.Task"/> passed has already been completed.
            </summary>
            <remarks>
            This is useful for a specific case: sometimes you might be calling an API that is "sometimes" async, and you're
            calling it from a synchronous method where you know it should have completed synchronously. This is an easy
            way to assert that while silencing any compiler complaints.
            </remarks>
        </member>
        <member name="T:Roslyn.Utilities.AsyncLazy`1.AsyncLazyImpl`1">
            <summary>
            Represents a value that can be retrieved synchronously or asynchronously by many clients.
            The value will be computed on-demand the moment the first client asks for it. While being
            computed, more clients can request the value. As long as there are outstanding clients the
            underlying computation will proceed.  If all outstanding clients cancel their request then
            the underlying value computation will be cancelled as well.
            
            Creators of an <see cref="T:Roslyn.Utilities.AsyncLazy`1" /> can specify whether the result of the computation is
            cached for future requests or not. Choosing to not cache means the computation functions are kept
            alive, whereas caching means the value (but not functions) are kept alive once complete.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.AsyncLazy`1.AsyncLazyImpl`1._asynchronousComputeFunction">
            <summary>
            The underlying function that starts an asynchronous computation of the resulting value.
            Null'ed out once we've computed the result and we've been asked to cache it.  Otherwise,
            it is kept around in case the value needs to be computed again.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.AsyncLazy`1.AsyncLazyImpl`1._synchronousComputeFunction">
            <summary>
            The underlying function that starts a synchronous computation of the resulting value.
            Null'ed out once we've computed the result and we've been asked to cache it, or if we
            didn't get any synchronous function given to us in the first place.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.AsyncLazy`1.AsyncLazyImpl`1._cachedResult">
            <summary>
            The Task that holds the cached result.
            </summary>
        </member>
        <member name="P:Roslyn.Utilities.AsyncLazy`1.AsyncLazyImpl`1.SyncObject">
            <summary>
            Mutex used to protect reading and writing to all mutable objects and fields.  Traces indicate that there's
            negligible contention on this lock (and on any particular async-lazy in general), hence we can save some
            memory by using ourselves as the lock, even though this may inhibit cancellation.  Work done while holding
            the lock should be kept to a minimum.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.AsyncLazy`1.AsyncLazyImpl`1._requests">
            <summary>
            The hash set of all currently outstanding asynchronous requests. Null if there are no requests,
            and will never be empty.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.AsyncLazy`1.AsyncLazyImpl`1._asynchronousComputationCancellationSource">
            <summary>
            If an asynchronous request is active, the CancellationTokenSource that allows for
            cancelling the underlying computation.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.AsyncLazy`1.AsyncLazyImpl`1._computationActive">
            <summary>
            Whether a computation is active or queued on any thread, whether synchronous or
            asynchronous.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.AsyncLazy`1.AsyncLazyImpl`1.#ctor(`0)">
            <summary>
            Creates an AsyncLazy that always returns the value, analogous to <see cref="M:System.Threading.Tasks.Task.FromResult``1(``0)" />.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.AsyncLazy`1.AsyncLazyImpl`1.#ctor(System.Func{`1,System.Threading.CancellationToken,System.Threading.Tasks.Task{`0}},System.Func{`1,System.Threading.CancellationToken,`0},`1)">
            <summary>
            Creates an AsyncLazy that supports both asynchronous computation and inline synchronous
            computation.
            </summary>
            <param name="asynchronousComputeFunction">A function called to start the asynchronous
            computation. This function should be cheap and non-blocking.</param>
            <param name="synchronousComputeFunction">A function to do the work synchronously, which
            is allowed to block. This function should not be implemented by a simple Wait on the
            asynchronous value. If that's all you are doing, just don't pass a synchronous function
            in the first place.</param>
        </member>
        <member name="M:Roslyn.Utilities.AsyncLazy`1.AsyncLazyImpl`1.TakeLock(System.Threading.CancellationToken)">
            <summary>
            Takes the lock for this object and if acquired validates the invariants of this class.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.AsyncLazy`1.AsyncLazyImpl`1.Request">
            <remarks>
            This inherits from <see cref="T:System.Threading.Tasks.TaskCompletionSource`1"/> to avoid allocating two objects when we can just use one.
            The public surface area of <see cref="T:System.Threading.Tasks.TaskCompletionSource`1"/> should probably be avoided in favor of the public
            methods on this class for correct behavior.
            </remarks>
        </member>
        <member name="F:Roslyn.Utilities.AsyncLazy`1.AsyncLazyImpl`1.Request._cancellationToken">
            <summary>
            The <see cref="T:System.Threading.CancellationToken"/> associated with this request. This field will be initialized before
            any cancellation is observed from the token.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.NonReentrantLock">
            <summary>
            A lightweight mutual exclusion object which supports waiting with cancellation and prevents
            recursion (i.e. you may not call Wait if you already hold the lock)
            </summary>
            <remarks>
            <para>
            The <see cref="T:Roslyn.Utilities.NonReentrantLock"/> provides a lightweight mutual exclusion class that doesn't
            use Windows kernel synchronization primitives.
            </para>
            <para>
            The implementation is distilled from the workings of <see cref="T:System.Threading.SemaphoreSlim"/>
            The basic idea is that we use a regular sync object (Monitor.Enter/Exit) to guard the setting
            of an 'owning thread' field. If, during the Wait, we find the lock is held by someone else
            then we register a cancellation callback and enter a "Monitor.Wait" loop. If the cancellation
            callback fires, then it "pulses" all the waiters to wake them up and check for cancellation.
            Waiters are also "pulsed" when leaving the lock.
            </para>
            <para>
            All public members of <see cref="T:Roslyn.Utilities.NonReentrantLock"/> are thread-safe and may be used concurrently
            from multiple threads.
            </para>
            </remarks>
        </member>
        <member name="F:Roslyn.Utilities.NonReentrantLock._syncLock">
            <summary>
            A synchronization object to protect access to the <see cref="F:Roslyn.Utilities.NonReentrantLock._owningThreadId"/> field and to be pulsed
            when <see cref="M:Roslyn.Utilities.NonReentrantLock.Release"/> is called and during cancellation.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.NonReentrantLock._owningThreadId">
            <summary>
            The <see cref="P:System.Environment.CurrentManagedThreadId" /> of the thread that holds the lock. Zero if no thread is holding
            the lock.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.NonReentrantLock.#ctor(System.Boolean)">
            <summary>
            Constructor.
            </summary>
            <param name="useThisInstanceForSynchronization">If false (the default), then the class
            allocates an internal object to be used as a sync lock.
            If true, then the sync lock object will be the NonReentrantLock instance itself. This
            saves an allocation but a client may not safely further use this instance in a call to
            Monitor.Enter/Exit or in a "lock" statement.
            </param>
        </member>
        <member name="F:Roslyn.Utilities.NonReentrantLock.Factory">
            <summary>
            Shared factory for use in lazy initialization.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.NonReentrantLock.Wait(System.Threading.CancellationToken)">
            <summary>
            Blocks the current thread until it can enter the <see cref="T:Roslyn.Utilities.NonReentrantLock"/>, while observing a
            <see cref="T:System.Threading.CancellationToken"/>.
            </summary>
            <remarks>
            Recursive locking is not supported. i.e. A thread may not call Wait successfully twice without an
            intervening <see cref="M:Roslyn.Utilities.NonReentrantLock.Release"/>.
            </remarks>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken"/> token to
            observe.</param>
            <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken"/> was
            canceled.</exception>
            <exception cref="T:System.Threading.LockRecursionException">The caller already holds the lock</exception>
        </member>
        <member name="M:Roslyn.Utilities.NonReentrantLock.Release">
            <summary>
            Exit the mutual exclusion.
            </summary>
            <remarks>
            The calling thread must currently hold the lock.
            </remarks>
            <exception cref="T:System.InvalidOperationException">The lock is not currently held by the calling thread.</exception>
        </member>
        <member name="M:Roslyn.Utilities.NonReentrantLock.LockHeldByMe">
            <summary>
            Determine if the lock is currently held by the calling thread.
            </summary>
            <returns>True if the lock is currently held by the calling thread.</returns>
        </member>
        <member name="M:Roslyn.Utilities.NonReentrantLock.AssertHasLock">
            <summary>
            Throw an exception if the lock is not held by the calling thread.
            </summary>
            <exception cref="T:System.InvalidOperationException">The lock is not currently held by the calling thread.</exception>
        </member>
        <member name="P:Roslyn.Utilities.NonReentrantLock.IsLocked">
            <summary>
            Checks if the lock is currently held.
            </summary>
        </member>
        <member name="P:Roslyn.Utilities.NonReentrantLock.IsOwnedByMe">
            <summary>
            Checks if the lock is currently held by the calling thread.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.NonReentrantLock.TakeOwnership">
            <summary>
            Take ownership of the lock (by the calling thread). The lock may not already
            be held by any other code.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.NonReentrantLock.ReleaseOwnership">
            <summary>
            Release ownership of the lock. The lock must already be held by the calling thread.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.NonReentrantLock.s_cancellationTokenCanceledEventHandler">
            <summary>
            Action object passed to a cancellation token registration.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.NonReentrantLock.CancellationTokenCanceledEventHandler(System.Object)">
            <summary>
            Callback executed when a cancellation token is canceled during a Wait.
            </summary>
            <param name="obj">The syncLock that protects a <see cref="T:Roslyn.Utilities.NonReentrantLock"/> instance.</param>
        </member>
        <member name="T:Roslyn.Utilities.NonReentrantLock.SemaphoreDisposer">
            <summary>
            Since we want to avoid boxing the return from <see cref="M:Roslyn.Utilities.NonReentrantLock.DisposableWait(System.Threading.CancellationToken)"/>, this type must be public.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.NonReentrantLock.SemaphoreDisposer.#ctor(Roslyn.Utilities.NonReentrantLock)">
            <summary>
            Since we want to avoid boxing the return from <see cref="M:Roslyn.Utilities.NonReentrantLock.DisposableWait(System.Threading.CancellationToken)"/>, this type must be public.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.FileNameUtilities">
            <summary>
            Implements a few file name utilities that are needed by the compiler.
            In general the compiler is not supposed to understand the format of the paths.
            In rare cases it needs to check if a string is a valid file name or change the extension 
            (embedded resources, netmodules, output name).
            The APIs are intentionally limited to cover just these rare cases. Do not add more APIs.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.FileNameUtilities.IsFileName(System.String)">
            <summary>
            Returns true if the string represents an unqualified file name. 
            The name may contain any characters but directory and volume separators.
            </summary>
            <param name="path">Path.</param>
            <returns>
            True if <paramref name="path"/> is a simple file name, false if it is null or includes a directory specification.
            </returns>
        </member>
        <member name="M:Roslyn.Utilities.FileNameUtilities.IndexOfExtension(System.String)">
            <summary>
            Returns the offset in <paramref name="path"/> where the dot that starts an extension is, or -1 if the path doesn't have an extension.
            </summary>
            <remarks>
            Returns 0 for path ".goo".
            Returns -1 for path "goo.".
            </remarks>
        </member>
        <member name="M:Roslyn.Utilities.FileNameUtilities.GetExtension(System.String)">
            <summary>
            Returns an extension of the specified path string.
            </summary>
            <remarks>
            The same functionality as <see cref="M:System.IO.Path.GetExtension(System.String)"/> but doesn't throw an exception
            if there are invalid characters in the path.
            </remarks>
        </member>
        <member name="M:Roslyn.Utilities.FileNameUtilities.RemoveExtension(System.String)">
            <summary>
            Removes extension from path.
            </summary>
            <remarks>
            Returns "goo" for path "goo.".
            Returns "goo.." for path "goo...".
            </remarks>
        </member>
        <member name="M:Roslyn.Utilities.FileNameUtilities.ChangeExtension(System.String,System.String)">
            <summary>
            Returns path with the extension changed to <paramref name="extension"/>.
            </summary>
            <returns>
            Equivalent of <see cref="M:System.IO.Path.ChangeExtension(System.String,System.String)"/>
            
            If <paramref name="path"/> is null, returns null. 
            If path does not end with an extension, the new extension is appended to the path.
            If extension is null, equivalent to <see cref="M:Roslyn.Utilities.FileNameUtilities.RemoveExtension(System.String)"/>.
            </returns>
        </member>
        <member name="M:Roslyn.Utilities.FileNameUtilities.IndexOfFileName(System.String)">
            <summary>
            Returns the position in given path where the file name starts.
            </summary>
            <returns>-1 if path is null.</returns>
        </member>
        <member name="M:Roslyn.Utilities.FileNameUtilities.GetFileName(System.String,System.Boolean)">
            <summary>
            Get file name from path.
            </summary>
            <remarks>Unlike <see cref="M:System.IO.Path.GetFileName(System.String)"/> doesn't check for invalid path characters.</remarks>
        </member>
        <member name="T:Roslyn.Utilities.PlatformInformation">
            <summary>
            This class provides simple properties for determining whether the current platform is Windows or Unix-based.
            We intentionally do not use System.Runtime.InteropServices.RuntimeInformation.IsOSPlatform(...) because
            it incorrectly reports 'true' for 'Windows' in desktop builds running on Unix-based platforms via Mono.
            </summary>
        </member>
        <member name="P:Roslyn.Utilities.PlatformInformation.IsUsingMonoRuntime">
            <summary>
            Are we running on .NET 5 or later using the Mono runtime?
            Will also return true when running on Mono itself; if necessary
            we can use IsRunningOnMono to distinguish.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.RoslynDebug.Assert(System.Boolean)">
            <inheritdoc cref="M:System.Diagnostics.Debug.Assert(System.Boolean)"/>
        </member>
        <member name="M:Roslyn.Utilities.RoslynDebug.Assert(System.Boolean,System.String)">
            <inheritdoc cref="M:System.Diagnostics.Debug.Assert(System.Boolean,System.String)"/>
        </member>
        <member name="M:Roslyn.Utilities.RoslynDebug.Assert(System.Boolean,Roslyn.Utilities.RoslynDebug.AssertInterpolatedStringHandler@)">
            <inheritdoc cref="M:System.Diagnostics.Debug.Assert(System.Boolean,System.String)"/>
        </member>
        <member name="M:Roslyn.Utilities.RoslynDebug.AssertOrFailFast(System.Boolean,System.String)">
            <summary>
            Generally <see cref="M:System.Diagnostics.Debug.Assert(System.Boolean)"/> is a sufficient method for enforcing DEBUG 
            only invariants in our code. When it triggers that provides a nice stack trace for 
            investigation. Generally that is enough.
            
            <para>There are cases for which a stack is not enough and we need a full heap dump to 
            investigate the failure. This method takes care of that. The behavior is that when running
            in our CI environment if the assert triggers we will rudely crash the process and 
            produce a heap dump for investigation.</para>
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.RoslynString.IsNullOrEmpty(System.String)">
            <inheritdoc cref="M:System.String.IsNullOrEmpty(System.String)"/>
        </member>
        <member name="M:Roslyn.Utilities.RoslynString.IsNullOrWhiteSpace(System.String)">
            <inheritdoc cref="M:System.String.IsNullOrWhiteSpace(System.String)"/>
        </member>
        <member name="M:Roslyn.Utilities.Hash.Combine(System.Int32,System.Int32)">
            <summary>
            This is how VB Anonymous Types combine hash values for fields.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.Hash.Combine``1(``0,System.Int32)">
            <summary>
            This is how VB Anonymous Types combine hash values for fields.
            PERF: Do not use with enum types because that involves multiple
            unnecessary boxing operations.  Unfortunately, we can't constrain
            T to "non-enum", so we'll use a more restrictive constraint.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.Hash.FnvOffsetBias">
            <summary>
            The offset bias value used in the FNV-1a algorithm
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.Hash.FnvPrime">
            <summary>
            The generative factor used in the FNV-1a algorithm
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.Hash.GetFNVHashCode(System.Byte[])">
            <summary>
            Compute the FNV-1a hash of a sequence of bytes
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="data">The sequence of bytes</param>
            <returns>The FNV-1a hash of <paramref name="data"/></returns>
        </member>
        <member name="M:Roslyn.Utilities.Hash.GetFNVHashCode(System.ReadOnlySpan{System.Byte},System.Boolean@)">
            <summary>
            Compute the FNV-1a hash of a sequence of bytes and determines if the byte
            sequence is valid ASCII and hence the hash code matches a char sequence
            encoding the same text.
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="data">The sequence of bytes that are likely to be ASCII text.</param>
            <param name="isAscii">True if the sequence contains only characters in the ASCII range.</param>
            <returns>The FNV-1a hash of <paramref name="data"/></returns>
        </member>
        <member name="M:Roslyn.Utilities.Hash.GetFNVHashCode(System.Collections.Immutable.ImmutableArray{System.Byte})">
            <summary>
            Compute the FNV-1a hash of a sequence of bytes
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="data">The sequence of bytes</param>
            <returns>The FNV-1a hash of <paramref name="data"/></returns>
        </member>
        <member name="M:Roslyn.Utilities.Hash.GetFNVHashCode(System.ReadOnlySpan{System.Char})">
            <summary>
            Compute the hashcode of a sub-string using FNV-1a
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            Note: FNV-1a was developed and tuned for 8-bit sequences. We're using it here
            for 16-bit Unicode chars on the understanding that the majority of chars will
            fit into 8-bits and, therefore, the algorithm will retain its desirable traits
            for generating hash codes.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.Hash.GetFNVHashCode(System.String,System.Int32,System.Int32)">
            <summary>
            Compute the hashcode of a sub-string using FNV-1a
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            Note: FNV-1a was developed and tuned for 8-bit sequences. We're using it here
            for 16-bit Unicode chars on the understanding that the majority of chars will
            fit into 8-bits and, therefore, the algorithm will retain its desirable traits
            for generating hash codes.
            </summary>
            <param name="text">The input string</param>
            <param name="start">The start index of the first character to hash</param>
            <param name="length">The number of characters, beginning with <paramref name="start"/> to hash</param>
            <returns>The FNV-1a hash code of the substring beginning at <paramref name="start"/> and ending after <paramref name="length"/> characters.</returns>
        </member>
        <member name="M:Roslyn.Utilities.Hash.GetFNVHashCode(System.String,System.Int32)">
            <summary>
            Compute the hashcode of a sub-string using FNV-1a
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="text">The input string</param>
            <param name="start">The start index of the first character to hash</param>
            <returns>The FNV-1a hash code of the substring beginning at <paramref name="start"/> and ending at the end of the string.</returns>
        </member>
        <member name="M:Roslyn.Utilities.Hash.GetFNVHashCode(System.String)">
            <summary>
            Compute the hashcode of a string using FNV-1a
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="text">The input string</param>
            <returns>The FNV-1a hash code of <paramref name="text"/></returns>
        </member>
        <member name="M:Roslyn.Utilities.Hash.GetFNVHashCode(System.Text.StringBuilder)">
            <summary>
            Compute the hashcode of a string using FNV-1a
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="text">The input string</param>
            <returns>The FNV-1a hash code of <paramref name="text"/></returns>
        </member>
        <member name="M:Roslyn.Utilities.Hash.GetFNVHashCode(System.Char[],System.Int32,System.Int32)">
            <summary>
            Compute the hashcode of a sub string using FNV-1a
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="text">The input string as a char array</param>
            <param name="start">The start index of the first character to hash</param>
            <param name="length">The number of characters, beginning with <paramref name="start"/> to hash</param>
            <returns>The FNV-1a hash code of the substring beginning at <paramref name="start"/> and ending after <paramref name="length"/> characters.</returns>
        </member>
        <member name="M:Roslyn.Utilities.Hash.GetFNVHashCode(System.Char)">
            <summary>
            Compute the hashcode of a single character using the FNV-1a algorithm
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            Note: In general, this isn't any more useful than "char.GetHashCode". However,
            it may be needed if you need to generate the same hash code as a string or
            substring with just a single character.
            </summary>
            <param name="ch">The character to hash</param>
            <returns>The FNV-1a hash code of the character.</returns>
        </member>
        <member name="M:Roslyn.Utilities.Hash.CombineFNVHash(System.Int32,System.String)">
            <summary>
            Combine a string with an existing FNV-1a hash code
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="hashCode">The accumulated hash code</param>
            <param name="text">The string to combine</param>
            <returns>The result of combining <paramref name="hashCode"/> with <paramref name="text"/> using the FNV-1a algorithm</returns>
        </member>
        <member name="M:Roslyn.Utilities.Hash.CombineFNVHash(System.Int32,System.Char)">
            <summary>
            Combine a char with an existing FNV-1a hash code
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="hashCode">The accumulated hash code</param>
            <param name="ch">The new character to combine</param>
            <returns>The result of combining <paramref name="hashCode"/> with <paramref name="ch"/> using the FNV-1a algorithm</returns>
        </member>
        <member name="M:Roslyn.Utilities.Hash.CombineFNVHash(System.Int32,System.ReadOnlySpan{System.Char})">
            <summary>
            Combine a string with an existing FNV-1a hash code
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="hashCode">The accumulated hash code</param>
            <param name="data">The string to combine</param>
            <returns>The result of combining <paramref name="hashCode"/> with <paramref name="data"/> using the FNV-1a algorithm</returns>
        </member>
        <member name="M:Roslyn.Utilities.FileUtilities.ResolveRelativePath(System.String,System.String,System.String,System.Collections.Generic.IEnumerable{System.String},System.Func{System.String,System.Boolean})">
            <summary>
            Resolves relative path and returns absolute path.
            The method depends only on values of its parameters and their implementation (for fileExists).
            It doesn't itself depend on the state of the current process (namely on the current drive directories) or 
            the state of file system.
            </summary>
            <param name="path">
            Path to resolve.
            </param>
            <param name="basePath">
            Base file path to resolve CWD-relative paths against. Null if not available.
            </param>
            <param name="baseDirectory">
            Base directory to resolve CWD-relative paths against if <paramref name="basePath"/> isn't specified. 
            Must be absolute path.
            Null if not available.
            </param>
            <param name="searchPaths">
            Sequence of paths used to search for unqualified relative paths.
            </param>
            <param name="fileExists">
            Method that tests existence of a file.
            </param>
            <returns>
            The resolved path or null if the path can't be resolved or does not exist.
            </returns>
        </member>
        <member name="M:Roslyn.Utilities.FileUtilities.NormalizeAbsolutePath(System.String)">
            <summary>
            Normalizes an absolute path.
            </summary>
            <param name="path">Path to normalize.</param>
            <exception cref="T:System.IO.IOException"/>
            <returns>Normalized path.</returns>
        </member>
        <member name="M:Roslyn.Utilities.FileUtilities.CreateFileStreamChecked(System.Func{System.String,System.IO.Stream},System.String,System.String)">
            <summary>
            Used to create a file given a path specified by the user.
            paramName - Provided by the Public surface APIs to have a clearer message. Internal API just rethrow the exception
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.FileUtilities.GetFileTimeStamp(System.String)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Roslyn.Utilities.FileUtilities.GetFileLength(System.String)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Roslyn.Utilities.FileUtilities.GetFileLengthAndTimeStamp(System.String,System.Int64@,System.DateTime@)">
            <exception cref="T:System.IO.IOException"/>
            <summary>
            Preferred mechanism to obtain both length and last write time of a file. Querying independently
            requires multiple i/o hits which are expensive, even if cached.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.IsDirectorySeparator(System.Char)">
            <summary>
            True if the character is the platform directory separator character or the alternate directory separator.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.IsAnyDirectorySeparator(System.Char)">
            <summary>
            True if the character is any recognized directory separator character.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.TrimTrailingSeparators(System.String)">
            <summary>
            Removes trailing directory separator characters
            </summary>
            <remarks>
            This will trim the root directory separator:
            "C:\" maps to "C:", and "/" maps to ""
            </remarks>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.EnsureTrailingSeparator(System.String)">
            <summary>
            Ensures a trailing directory separator character
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.GetDirectoryName(System.String)">
            <summary>
            Get directory name from path.
            </summary>
            <remarks>
            Unlike <see cref="M:System.IO.Path.GetDirectoryName(System.String)"/> it doesn't check for invalid path characters
            </remarks>
            <returns>Prefix of path that represents a directory</returns>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.GetPathRoot(System.String)">
            <summary>
            Gets the root part of the path.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.GetPathKind(System.String)">
            <summary>
            Gets the specific kind of relative or absolute path.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.IsAbsolute(System.String)">
            <summary>
            True if the path is an absolute path (rooted to drive or network share)
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.IsDriveRootedAbsolutePath(System.String)">
            <summary>
            Returns true if given path is absolute and starts with a drive specification ("C:\").
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.CombineAbsoluteAndRelativePaths(System.String,System.String)">
            <summary>
            Combines an absolute path with a relative.
            </summary>
            <param name="root">Absolute root path.</param>
            <param name="relativePath">Relative path.</param>
            <returns>
            An absolute combined path, or null if <paramref name="relativePath"/> is 
            absolute (e.g. "C:\abc", "\\machine\share\abc"), 
            relative to the current root (e.g. "\abc"), 
            or relative to a drive directory (e.g. "C:abc\def").
            </returns>
            <seealso cref="M:Roslyn.Utilities.PathUtilities.CombinePossiblyRelativeAndRelativePaths(System.String,System.String)"/>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.CombinePossiblyRelativeAndRelativePaths(System.String,System.String)">
            <summary>
            Combine two paths, the first of which may be absolute.
            </summary>
            <param name="root">First path: absolute, relative, or null.</param>
            <param name="relativePath">Second path: relative and non-null.</param>
            <returns>null, if <paramref name="root"/> is null; a combined path, otherwise.</returns>
            <seealso cref="M:Roslyn.Utilities.PathUtilities.CombineAbsoluteAndRelativePaths(System.String,System.String)"/>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.CombinePaths(System.String,System.String)">
            <summary>
            Combines paths with the same semantics as <see cref="M:System.IO.Path.Combine(System.String,System.String)"/>
            but does not throw on null paths or paths with invalid characters.
            </summary>
            <param name="root">First path: absolute, relative, or null.</param>
            <param name="path">Second path: absolute, relative, or null.</param>
            <returns>
            The combined paths. If <paramref name="path"/> contains an absolute path, returns <paramref name="path"/>.
            </returns>
            <remarks>
            Relative and absolute paths treated the same as <see cref="M:System.IO.Path.Combine(System.String,System.String)"/>.
            </remarks>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.IsFilePath(System.String)">
            <summary>
            Determines whether an assembly reference is considered an assembly file path or an assembly name.
            used, for example, on values of /r and #r.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.ContainsPathComponent(System.String,System.String,System.Boolean)">
            <summary>
            Determines if "path" contains 'component' within itself.
            i.e. asking if the path "c:\goo\bar\baz" has component "bar" would return 'true'.
            On the other hand, if you had "c:\goo\bar1\baz" then it would not have "bar" as a
            component.
            
            A path contains a component if any file name or directory name in the path
            matches 'component'.  As such, if you had something like "\\goo" then that would
            not have "goo" as a component. That's because here "goo" is the server name portion
            of the UNC path, and not an actual directory or file name.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.GetRelativePath(System.String,System.String)">
            <summary>
            Gets a path relative to a directory.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.IsChildPath(System.String,System.String)">
            <summary>
            True if the child path is a child of the parent path.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.PathsEqual(System.String,System.String)">
            <summary>
            True if the two paths are the same.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.PathsEqual(System.String,System.String,System.Int32)">
            <summary>
            True if the two paths are the same.  (but only up to the specified length)
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.IsValidFilePath(System.String)">
            <summary>
            Unfortunately, we cannot depend on Path.GetInvalidPathChars() or Path.GetInvalidFileNameChars()
            From MSDN: The array returned from this method is not guaranteed to contain the complete set of characters
            that are invalid in file and directory names. The full set of invalid characters can vary by file system.
            https://msdn.microsoft.com/en-us/library/system.io.path.getinvalidfilenamechars.aspx
            
            Additionally, Path.GetInvalidPathChars() doesn't include "?" or "*" which are invalid characters,
            and Path.GetInvalidFileNameChars() includes ":" and "\" which are valid characters.
            
            The more accurate way is to let the framework parse the path and throw on any errors.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.NormalizeWithForwardSlash(System.String)">
            <summary>
            If the current environment uses the '\' directory separator, replaces all uses of '\'
            in the given string with '/'. Otherwise, returns the string.
            </summary>
            <remarks>
            This method is equivalent to Microsoft.CodeAnalysis.BuildTasks.GenerateMSBuildEditorConfig.NormalizeWithForwardSlash
            Both methods should be kept in sync.
            </remarks>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.CollapseWithForwardSlash(System.ReadOnlySpan{System.Char})">
            <summary>
            Replaces all sequences of '\' or '/' with a single '/' but preserves UNC prefix '//'.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.ExpandAbsolutePathWithRelativeParts(System.String)">
            <summary>
            Takes an absolute path and attempts to expand any '..' or '.' into their equivalent representation.
            </summary>
            <returns>An equivalent path that does not contain any '..' or '.' path parts, or the original path.</returns>
            <remarks>
            This method handles unix and windows drive rooted absolute paths only (i.e /a/b or x:\a\b). Passing any other kind of path
            including relative, drive relative, unc, or windows device paths will simply return the original input. 
            </remarks>
        </member>
        <member name="F:Roslyn.Utilities.PathKind.Empty">
            <summary>
            Null or empty.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.PathKind.Relative">
            <summary>
            "file"
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.PathKind.RelativeToCurrentDirectory">
            <summary>
            ".\file"
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.PathKind.RelativeToCurrentParent">
            <summary>
            "..\file"
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.PathKind.RelativeToCurrentRoot">
            <summary>
            "\dir\file"
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.PathKind.RelativeToDriveDirectory">
            <summary>
            "C:dir\file"
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.PathKind.Absolute">
            <summary>
            "C:\file" or "\\machine" (UNC).
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.PerformanceSensitiveAttribute">
            <summary>
            Indicates that a code element is performance sensitive under a known scenario.
            </summary>
            <remarks>
            <para>When applying this attribute, only explicitly set the values for properties specifically indicated by the
            test/measurement technique described in the associated <see cref="P:Roslyn.Utilities.PerformanceSensitiveAttribute.Uri"/>.</para>
            </remarks>
        </member>
        <member name="P:Roslyn.Utilities.PerformanceSensitiveAttribute.Uri">
            <summary>
            Gets the location where the original problem is documented, likely with steps to reproduce the issue and/or
            validate performance related to a change in the method.
            </summary>
        </member>
        <member name="P:Roslyn.Utilities.PerformanceSensitiveAttribute.Constraint">
            <summary>
            Gets or sets a description of the constraint imposed by the original performance issue.
            </summary>
            <remarks>
            <para>Constraints are normally specified by other specific properties that allow automated validation of the
            constraint. This property supports documenting constraints which cannot be described in terms of other
            constraint properties.</para>
            </remarks>
        </member>
        <member name="P:Roslyn.Utilities.PerformanceSensitiveAttribute.AllowCaptures">
            <summary>
            Gets or sets a value indicating whether captures are allowed.
            </summary>
        </member>
        <member name="P:Roslyn.Utilities.PerformanceSensitiveAttribute.AllowImplicitBoxing">
            <summary>
            Gets or sets a value indicating whether implicit boxing of value types is allowed.
            </summary>
        </member>
        <member name="P:Roslyn.Utilities.PerformanceSensitiveAttribute.AllowGenericEnumeration">
            <summary>
            Gets or sets a value indicating whether enumeration of a generic
            <see cref="T:System.Collections.Generic.IEnumerable`1"/> is allowed.
            </summary>
        </member>
        <member name="P:Roslyn.Utilities.PerformanceSensitiveAttribute.AllowLocks">
            <summary>
            Gets or sets a value indicating whether locks are allowed.
            </summary>
        </member>
        <member name="P:Roslyn.Utilities.PerformanceSensitiveAttribute.OftenCompletesSynchronously">
            <summary>
            Gets or sets a value indicating whether the asynchronous state machine typically completes synchronously.
            </summary>
            <remarks>
            <para>When <see langword="true"/>, validation of this performance constraint typically involves analyzing
            the method to ensure synchronous completion of the state machine does not require the allocation of a
            <see cref="T:System.Threading.Tasks.Task"/>, either through caching the result or by using
            <see cref="T:System.Threading.Tasks.ValueTask`1"/>.</para>
            </remarks>
        </member>
        <member name="P:Roslyn.Utilities.PerformanceSensitiveAttribute.IsParallelEntry">
            <summary>
            Gets or sets a value indicating whether this is an entry point to a parallel algorithm.
            </summary>
            <remarks>
            <para>Parallelization APIs and algorithms, e.g. <c>Parallel.ForEach</c>, may be efficient for parallel entry
            points (few direct calls but large amounts of iterative work), but are problematic when called inside the
            iterations themselves. Performance-sensitive code should avoid the use of heavy parallelization APIs except
            for known entry points to the parallel portion of code.</para>
            </remarks>
        </member>
        <member name="T:System.Linq.ImmutableSegmentedListExtensions">
            <seealso cref="T:System.Linq.ImmutableArrayExtensions"/>
        </member>
        <member name="T:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute">
            <summary>
            Indicates that compiler support for a particular feature is required for the location where this attribute is applied.
            </summary>
        </member>
        <member name="P:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.FeatureName">
            <summary>
            The name of the compiler feature.
            </summary>
        </member>
        <member name="P:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.IsOptional">
            <summary>
            If true, the compiler can choose to allow access to the location where this attribute is applied if it does not understand <see cref="P:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.FeatureName"/>.
            </summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.RefStructs">
            <summary>
            The <see cref="P:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.FeatureName"/> used for the ref structs C# feature.
            </summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.RequiredMembers">
            <summary>
            The <see cref="P:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.FeatureName"/> used for the required members C# feature.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute">
            <summary>Indicates which arguments to a method involving an interpolated string handler should be passed to that handler.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute.#ctor(System.String)">
            <summary>Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute"/> class.</summary>
            <param name="argument">The name of the argument that should be passed to the handler.</param>
            <remarks><see langword="null"/> may be used as the name of the receiver in an instance method.</remarks>
        </member>
        <member name="M:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute.#ctor(System.String[])">
            <summary>Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute"/> class.</summary>
            <param name="arguments">The names of the arguments that should be passed to the handler.</param>
            <remarks><see langword="null"/> may be used as the name of the receiver in an instance method.</remarks>
        </member>
        <member name="P:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute.Arguments">
            <summary>Gets the names of the arguments that should be passed to the handler.</summary>
            <remarks><see langword="null"/> may be used as the name of the receiver in an instance method.</remarks>
        </member>
        <member name="T:System.Runtime.CompilerServices.InterpolatedStringHandlerAttribute">
            <summary>Indicates the attributed type is to be used as an interpolated string handler.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.InterpolatedStringHandlerAttribute.#ctor">
            <summary>Initializes the <see cref="T:System.Runtime.CompilerServices.InterpolatedStringHandlerAttribute"/>.</summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.IsExternalInit">
            <summary>
            Reserved to be used by the compiler for tracking metadata.
            This class should not be used by developers in source code.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.RequiredMemberAttribute">
            <summary>Specifies that a type has required members or that a member is required.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.ExperimentalAttribute">
            <summary>
             Indicates that an API is experimental and it may change in the future.
            </summary>
            <remarks>
              This attribute allows call sites to be flagged with a diagnostic that indicates that an experimental
              feature is used. Authors can use this attribute to ship preview features in their assemblies.
            </remarks>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.ExperimentalAttribute.#ctor(System.String)">
            <summary>
             Initializes a new instance of the <see cref="T:System.Diagnostics.CodeAnalysis.ExperimentalAttribute"/> class, specifying the ID that the compiler will use
             when reporting a use of the API the attribute applies to.
            </summary>
            <param name="diagnosticId">The ID that the compiler will use when reporting a use of the API the attribute applies to.</param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.ExperimentalAttribute.DiagnosticId">
            <summary>
             Gets the ID that the compiler will use when reporting a use of the API the attribute applies to.
            </summary>
            <value>The unique diagnostic ID.</value>
            <remarks>
             The diagnostic ID is shown in build output for warnings and errors.
             <para>This property represents the unique ID that can be used to suppress the warnings or errors, if needed.</para>
            </remarks>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.ExperimentalAttribute.UrlFormat">
            <summary>
             Gets or sets the URL for corresponding documentation.
             The API accepts a format string instead of an actual URL, creating a generic URL that includes the diagnostic ID.
            </summary>
            <value>The format string that represents a URL to corresponding documentation.</value>
            <remarks>An example format string is <c>https://contoso.com/obsoletion-warnings/{0}</c>.</remarks>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.AllowNullAttribute">
            <summary>Specifies that null is allowed as an input even if the corresponding type disallows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DisallowNullAttribute">
            <summary>Specifies that null is disallowed as an input even if the corresponding type allows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MaybeNullAttribute">
            <summary>Specifies that an output may be null even if the corresponding type disallows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullAttribute">
            <summary>Specifies that an output will not be null even if the corresponding type allows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute">
            <summary>Specifies that when a method returns <see cref="P:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.ReturnValue"/>, the parameter may be null even if the corresponding type disallows it.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.#ctor(System.Boolean)">
            <summary>Initializes the attribute with the specified return value condition.</summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter may be null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.ReturnValue">
            <summary>Gets the return value condition.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute">
            <summary>Specifies that when a method returns <see cref="P:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.ReturnValue"/>, the parameter will not be null even if the corresponding type allows it.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.#ctor(System.Boolean)">
            <summary>Initializes the attribute with the specified return value condition.</summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter will not be null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.ReturnValue">
            <summary>Gets the return value condition.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute">
            <summary>Specifies that the output will be non-null if the named parameter is non-null.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute.#ctor(System.String)">
            <summary>Initializes the attribute with the associated parameter name.</summary>
            <param name="parameterName">
            The associated parameter name.  The output will be non-null if the argument to the parameter specified is non-null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute.ParameterName">
            <summary>Gets the associated parameter name.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute">
            <summary>Applied to a method that will never return under any circumstance.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute">
            <summary>Specifies that the method will not return if the associated Boolean parameter is passed the specified value.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute.#ctor(System.Boolean)">
            <summary>Initializes the attribute with the specified parameter value.</summary>
            <param name="parameterValue">
            The condition parameter value. Code after the method will be considered unreachable by diagnostics if the argument to
            the associated parameter matches this value.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute.ParameterValue">
            <summary>Gets the condition parameter value.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute">
            <summary>Specifies that the method or property will ensure that the listed field and property members have not-null values.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.#ctor(System.String)">
            <summary>Initializes the attribute with a field or property member.</summary>
            <param name="member">
            The field or property member that is promised to be not-null.
            </param>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.#ctor(System.String[])">
            <summary>Initializes the attribute with the list of field and property members.</summary>
            <param name="members">
            The list of field and property members that are promised to be not-null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.Members">
            <summary>Gets field or property member names.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute">
            <summary>Specifies that the method or property will ensure that the listed field and property members have not-null values when returning with the specified return value condition.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.#ctor(System.Boolean,System.String)">
            <summary>Initializes the attribute with the specified return value condition and a field or property member.</summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter will not be null.
            </param>
            <param name="member">
            The field or property member that is promised to be not-null.
            </param>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.#ctor(System.Boolean,System.String[])">
            <summary>Initializes the attribute with the specified return value condition and list of field and property members.</summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter will not be null.
            </param>
            <param name="members">
            The list of field and property members that are promised to be not-null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.ReturnValue">
            <summary>Gets the return value condition.</summary>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.Members">
            <summary>Gets field or property member names.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.SetsRequiredMembersAttribute">
            <summary>
            Specifies that this constructor sets all required members for the current type, and callers
            do not need to set any required members themselves.
            </summary>
        </member>
        <member name="T:System.Collections.Generic.IReadOnlySet`1">
            <summary>
            Provides a readonly abstraction of a set.
            </summary>
            <typeparam name="T">The type of elements in the set.</typeparam>
        </member>
        <member name="M:System.Collections.Generic.IReadOnlySet`1.Contains(`0)">
            <summary>
            Determines if the set contains a specific item
            </summary>
            <param name="item">The item to check if the set contains.</param>
            <returns><see langword="true" /> if found; otherwise <see langword="false" />.</returns>
        </member>
        <member name="M:System.Collections.Generic.IReadOnlySet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Determines whether the current set is a proper (strict) subset of a specified collection.
            </summary>
            <param name="other">The collection to compare to the current set.</param>
            <returns><see langword="true" /> if the current set is a proper subset of other; otherwise <see langword="false" />.</returns>
            <exception cref="T:System.ArgumentNullException">other is <see langword="null" />.</exception>
        </member>
        <member name="M:System.Collections.Generic.IReadOnlySet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Determines whether the current set is a proper (strict) superset of a specified collection.
            </summary>
            <param name="other">The collection to compare to the current set.</param>
            <returns><see langword="true" /> if the collection is a proper superset of other; otherwise <see langword="false" />.</returns>
            <exception cref="T:System.ArgumentNullException">other is <see langword="null" />.</exception>
        </member>
        <member name="M:System.Collections.Generic.IReadOnlySet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Determine whether the current set is a subset of a specified collection.
            </summary>
            <param name="other">The collection to compare to the current set.</param>
            <returns><see langword="true" /> if the current set is a subset of other; otherwise <see langword="false" />.</returns>
            <exception cref="T:System.ArgumentNullException">other is <see langword="null" />.</exception>
        </member>
        <member name="M:System.Collections.Generic.IReadOnlySet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Determine whether the current set is a super set of a specified collection.
            </summary>
            <param name="other">The collection to compare to the current set</param>
            <returns><see langword="true" /> if the current set is a subset of other; otherwise <see langword="false" />.</returns>
            <exception cref="T:System.ArgumentNullException">other is <see langword="null" />.</exception>
        </member>
        <member name="M:System.Collections.Generic.IReadOnlySet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Determines whether the current set overlaps with the specified collection.
            </summary>
            <param name="other">The collection to compare to the current set.</param>
            <returns><see langword="true" /> if the current set and other share at least one common element; otherwise, <see langword="false" />.</returns>
            <exception cref="T:System.ArgumentNullException">other is <see langword="null" />.</exception>
        </member>
        <member name="M:System.Collections.Generic.IReadOnlySet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Determines whether the current set and the specified collection contain the same elements.
            </summary>
            <param name="other">The collection to compare to the current set.</param>
            <returns><see langword="true" /> if the current set is equal to other; otherwise, <see langword="false" />.</returns>
            <exception cref="T:System.ArgumentNullException">other is <see langword="null" />.</exception>
        </member>
    </members>
</doc>
